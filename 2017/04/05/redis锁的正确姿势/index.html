<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Redis锁的正确姿势 · Fitzix</title><meta name="description" content="Redis锁的正确姿势 - fitzix"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/fitzix/atom.xml" title="Fitzix"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/14334411?s=460&amp;v=4" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fitzix" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Redis锁的正确姿势</h1><div class="tags"><a href="/tags/PHP-Redis/" class="tag-title">#PHP Redis</a></div><div class="post-info">Apr 5, 2017</div><div class="post-content"><p>redis是php的好朋友，在php写业务过程中，有时候会使用到锁的概念，同时只能有一个人可以操作某个行为。这个时候我们就要用到锁。锁的方式有好几种，php不能在内存中用锁，不能使用zookeeper加锁，使用数据库做锁又消耗比较大，这个时候我们一般会选用redis做锁机制。</p>
<a id="more"></a>
<blockquote>
<p>setnx</p>
</blockquote>
<p>锁在redis中最简单的数据结构就是string。最早的时候，上锁的操作一般使用setnx，这个命令是当:lock不存在的时候set一个val，或许你还会记得使用expire来增加锁的过期，解锁操作就是使用del命令，伪代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Redis::setnx(<span class="string">"my:lock"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    Redis::expire(<span class="string">"my:lock"</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line"></span><br><span class="line">    Redis::del(<span class="string">"my:lock"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实是有问题的，问题就在于setnx和expire中间如果遇到crash等行为，可能这个lock就不会被释放了。于是进一步的优化方案可能是在lock中存储timestamp。判断timestamp的长短。</p>
<blockquote>
<p>set</p>
</blockquote>
<p>现在官方建议直接使用set来实现锁。我们可以使用set命令来替代setnx，就是下面这个样子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Redis::set(<span class="string">"my:lock"</span>, <span class="number">1</span>, <span class="string">"nx"</span>, <span class="string">"ex"</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">    ... <span class="keyword">do</span> something</span><br><span class="line"></span><br><span class="line">    Redis::del(<span class="string">"my:lock"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码把my:lock设置为1，当且仅当这个lock不存在的时候，设置完成之后设置过期时间为10。</p>
<p>获取锁的机制是对了，但是删除锁的机制直接使用del是不对的。因为有可能导致误删别人的锁的情况。</p>
<p>比如，这个锁我上了10s，但是我处理的时间比10s更长，到了10s，这个锁自动过期了，被别人取走了，并且对它重新上锁了。那么这个时候，我再调用Redis::del就是删除别人建立的锁了。</p>
<p>官方对解锁的命令也有建议，建议使用lua脚本，先进行get，再进行del</p>
<p>程序变成：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$token = rand(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Redis::set(<span class="string">"my:lock"</span>, $token, <span class="string">"nx"</span>, <span class="string">"ex"</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $script = `</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]</span><br><span class="line">then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end    </span><br><span class="line">    `</span><br><span class="line">    <span class="keyword">return</span> Redis::eval($script, <span class="string">"my:lock"</span>, $token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lock()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的token是一个随机数，当lock的时候，往redis的my:lock中存的是这个token，unlock的时候，先get一下lock中的token，如果和我要删除的token是一致的，说明这个锁是之前我set的，否则的话，说明这个锁已经过期，是别人set的，我就不应该对它进行任何操作。</p>
<p>所以：不要再使用setnx，直接使用set进行锁实现。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/10/redis常用数据结构和操作/" class="prev">PREV</a><a href="/2017/03/12/web请求流程/" class="next">NEXT</a></div><div id="gitalk-container"></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
    clientID: '0005895a71d0d3de1ae6',
    clientSecret: 'e8a1b830b9588e99b5369bcf5ca60778420aec55',
    repo: 'fitzix.github.io',
    owner: 'fitzix',
    admin: ['fitzix'],
    id: location.pathname.substring(1, 51),
    distractionFreeMode: false  // Facebook-like distraction free mode
});
gitalk.render('gitalk-container');</script><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/fitzix">fitzix</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/fitzix/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-137176691-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())
gtag('config', 'UA-137176691-1');</script></body></html>