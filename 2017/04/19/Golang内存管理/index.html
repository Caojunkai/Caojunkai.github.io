<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Golang内存管理 · Fitzix</title><meta name="description" content="Golang内存管理 - fitzix"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/fitzix/atom.xml" title="Fitzix"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/14334411?s=460&amp;v=4" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fitzix" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Golang内存管理</h1><div class="tags"><a href="/tags/Go/" class="tag-title">#Go</a><a href="/tags/Go源码分析/" class="tag-title">#Go源码分析</a></div><div class="post-info">Apr 19, 2017</div><div class="post-content"><p>Golang 的内存管理基于 tcmalloc，可以说起点挺高的。但是 Golang 在实现的时候还做了很多优化，我们下面通过源码来看一下 Golang 的内存管理实现。下面的源码分析基于 go1.8rc3。</p>
<a id="more"></a>
<h3 id="tcmalloc-介绍"><a href="#tcmalloc-介绍" class="headerlink" title="tcmalloc 介绍"></a>tcmalloc 介绍</h3><p>关于 tcmalloc 可以参考这篇文章 <a href="http://legendtkl.com/2015/12/11/go-memory/" target="_blank" rel="noopener">tcmalloc</a> 介绍，原始论文可以参考 TCMalloc : Thread-Caching Malloc。</p>
<h3 id="Golang-内存管理"><a href="#Golang-内存管理" class="headerlink" title="Golang 内存管理"></a>Golang 内存管理</h3><h4 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h4><p>这里先简单介绍一下 Golang 运行调度。在 Golang 里面有三个基本的概念：G, M, P。</p>
<ul>
<li>G: Goroutine 执行的上下文环境</li>
<li>M: 操作系统线程</li>
<li>P: Processer。进程调度的关键，调度器，也可以认为约等于 CPU</li>
</ul>
<p>一个 Goroutine 的运行需要 G + P + M 三部分结合起来。好，先简单介绍到这里，更详细的放在后面的文章里面来说</p>
<h4 id="逃逸分析（escape-analysis）"><a href="#逃逸分析（escape-analysis）" class="headerlink" title="逃逸分析（escape analysis）"></a>逃逸分析（escape analysis）</h4><p>对于手动管理内存的语言，比如 C/C++，我们使用 malloc 或者 new 申请的变量会被分配到堆上。但是 Golang 并不是这样，虽然 Golang 语言里面也有 new。Golang 编译器决定变量应该分配到什么地方时会进行逃逸分析。下面是一个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> *x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>将上面文件保存为 escape.go，执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run -gcflags &apos;-m -l&apos; escape.go</span><br><span class="line">./escape.go:6: moved to heap: x</span><br><span class="line">./escape.go:7: &amp;x escape to heap</span><br><span class="line">./escape.go:11: bar new(int) does not escape</span><br></pre></td></tr></table></figure>
<p>上面的意思是 foo() 中的 x 最后在堆上分配，而 bar() 中的 x 最后分配在了栈上。在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：</p>
<p>How do I know whether a variable is allocated on the heap or the stack?</p>
<blockquote>
<p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
</blockquote>
<p>简单翻译一下:</p>
<p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p>
<blockquote>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。</p>
</blockquote>
<h4 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><p>几个关键的地方：</p>
<ul>
<li>mcache: per-P cache，可以认为是 local cache</li>
<li>mcentral: 全局 cache，mcache 不够用的时候向 mcentral 申请</li>
<li>mheap: 当 mcentral 也不够用的时候，通过 mheap 向操作系统申请</li>
</ul>
<p>可以将其看成多级内存分配器。</p>
<h5 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h5><p>我们知道每个 Gorontine 的运行都是绑定到一个 P 上面，mcache 是每个 P 的 cache。这么做的好处是分配内存时不需要加锁。mcache 结构如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-thread (in Go, per-P) cache for small objects.</span></span><br><span class="line"><span class="comment">// No locking needed because it is per-thread (per-P).</span></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The following members are accessed on every malloc,</span></span><br><span class="line">    <span class="comment">// so they are grouped here for better caching.</span></span><br><span class="line">    next_sample <span class="keyword">int32</span>   <span class="comment">// trigger heap sample after allocating this many bytes</span></span><br><span class="line">    local_scan  <span class="keyword">uintptr</span> <span class="comment">// bytes of scannable heap allocated</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小对象分配器，小于 16 byte 的小对象都会通过 tiny 来分配。</span></span><br><span class="line">    tiny             <span class="keyword">uintptr</span></span><br><span class="line">    tinyoffset       <span class="keyword">uintptr</span></span><br><span class="line">    local_tinyallocs <span class="keyword">uintptr</span> <span class="comment">// number of tiny allocs not counted in other stats</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The rest is not accessed on every malloc.</span></span><br><span class="line">    alloc [_NumSizeClasses]*mspan <span class="comment">// spans to allocate from</span></span><br><span class="line"></span><br><span class="line">    stackcache [_NumStackOrders]stackfreelist</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local allocator stats, flushed during GC.</span></span><br><span class="line">    local_nlookup    <span class="keyword">uintptr</span>                  <span class="comment">// number of pointer lookups</span></span><br><span class="line">    local_largefree  <span class="keyword">uintptr</span>                  <span class="comment">// bytes freed for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    local_nlargefree <span class="keyword">uintptr</span>                  <span class="comment">// number of frees for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    local_nsmallfree [_NumSizeClasses]<span class="keyword">uintptr</span> <span class="comment">// number of frees for small objects (&lt;=maxsmallsize)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以暂时只关注 alloc [_NumSizeClasses]*mspan，这是一个大小为 67 的指针（指针指向 mspan ）数组（_NumSizeClasses = 67），每个数组元素用来包含特定大小的块。当要分配内存大小时，为 object 在 alloc 数组中选择合适的元素来分配。67 种块大小为 0，8 byte, 16 byte, … ，这个和 tcmalloc 稍有区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: sizeclasses.go</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里仔细想有个小问题，上面的 alloc 类似内存池的 freelist 数组或者链表，正常实现每个数组元素是一个链表，链表由特定大小的块串起来。但是这里统一使用了 mspan 结构，那么只有一种可能，就是 mspan 中记录了需要分配的块大小。我们来看一下 mspan 的结构。</p>
<h5 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h5><p>span 在 tcmalloc 中作为一种管理内存的基本单位而存在。Golang 的 mspan 的结构如下，省略了部分内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan     <span class="comment">// next span in list, or nil if none</span></span><br><span class="line">    prev *mspan     <span class="comment">// previous span in list, or nil if none</span></span><br><span class="line">    list *mSpanList <span class="comment">// For debugging. <span class="doctag">TODO:</span> Remove.</span></span><br><span class="line"></span><br><span class="line">    startAddr     <span class="keyword">uintptr</span>   <span class="comment">// address of first byte of span aka s.base()</span></span><br><span class="line">    npages        <span class="keyword">uintptr</span>   <span class="comment">// number of pages in span</span></span><br><span class="line">    stackfreelist gclinkptr <span class="comment">// list of free stacks, avoids overloading freelist</span></span><br><span class="line">    <span class="comment">// freeindex is the slot index between 0 and nelems at which to begin scanning</span></span><br><span class="line">    <span class="comment">// for the next free object in this span.</span></span><br><span class="line">    freeindex <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Look up nelems from sizeclass and remove this field if it</span></span><br><span class="line">    <span class="comment">// helps performance.</span></span><br><span class="line">    nelems <span class="keyword">uintptr</span> <span class="comment">// number of object in the span.</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 用位图来管理可用的 free object，1 表示可用</span></span><br><span class="line">    allocCache <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    sizeclass   <span class="keyword">uint8</span>      <span class="comment">// size class</span></span><br><span class="line">    ...</span><br><span class="line">    elemsize    <span class="keyword">uintptr</span>    <span class="comment">// computed from sizeclass or from npages</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的结构可以看出：</p>
<ul>
<li>next, prev: 指针域，因为 mspan 一般都是以链表形式使用</li>
<li>npages: mspan 的大小为 page 大小的整数倍</li>
<li>sizeclass: 0 ~ _NumSizeClasses 之间的一个值，这个解释了我们的疑问。比如，sizeclass = 3，那么这个 mspan 被分割成 32 byte 的块</li>
<li>elemsize: 通过 sizeclass 或者 npages 可以计算出来。比如 sizeclass = 3, elemsize = 32 byte。对于大于 32Kb 的内存分配，都是分配整数页，elemsize = page_size * npages</li>
<li>nelems: span 中包块的总数目</li>
<li>freeindex: 0 ~ nelemes-1，表示分配到第几个块</li>
</ul>
<h6 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h6><p>上面说到当 mcache 不够用的时候，会从 mcentral 申请。那我们下面就来介绍一下 mcentral。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex</span><br><span class="line">    sizeclass <span class="keyword">int32</span></span><br><span class="line">    nonempty  mSpanList <span class="comment">// list of spans with a free object, ie a nonempty free list</span></span><br><span class="line">    empty     mSpanList <span class="comment">// list of spans with no free objects (or cached in an mcache)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mSpanList <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *mspan</span><br><span class="line">    last  *mspan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mcentral 分析：</p>
<ul>
<li>sizeclass: 也有成员 sizeclass，那么 mcentral 是不是也有 67 个呢？是的</li>
<li>lock: 因为会有多个 P 过来竞争</li>
<li>nonempty: mspan 的双向链表，当前 mcentral 中可用的 mspan list</li>
<li>empty: 已经被使用的，可以认为是一种对所有 mspan 的 track</li>
</ul>
<p>问题来了，mcentral 存在于什么地方？虽然在上面我们将 mcentral 和 mheap 作为两个部分来讲，但是作为全局的结构，这两部分是可以定义在一起的。实际上也是这样，mcentral 包含在 mheap 中。</p>
<h5 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex</span><br><span class="line">    free      [_MaxMHeapList]mSpanList <span class="comment">// free lists of given length</span></span><br><span class="line">    freelarge mSpanList                <span class="comment">// free lists length &gt;= _MaxMHeapList</span></span><br><span class="line">    busy      [_MaxMHeapList]mSpanList <span class="comment">// busy lists of large objects of given length</span></span><br><span class="line">    busylarge mSpanList                <span class="comment">// busy lists of large objects length &gt;= _MaxMHeapList</span></span><br><span class="line">    sweepgen  <span class="keyword">uint32</span>                   <span class="comment">// sweep generation, see comment in mspan</span></span><br><span class="line">    sweepdone <span class="keyword">uint32</span>                   <span class="comment">// all spans are swept</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allspans is a slice of all mspans ever created. Each mspan</span></span><br><span class="line">    <span class="comment">// appears exactly once.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The memory for allspans is manually managed and can be</span></span><br><span class="line">    <span class="comment">// reallocated and move as the heap grows.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// In general, allspans is protected by mheap_.lock, which</span></span><br><span class="line">    <span class="comment">// prevents concurrent access as well as freeing the backing</span></span><br><span class="line">    <span class="comment">// store. Accesses during STW might not hold the lock, but</span></span><br><span class="line">    <span class="comment">// must ensure that allocation cannot happen around the</span></span><br><span class="line">    <span class="comment">// access (since that may free the backing store).</span></span><br><span class="line">    allspans []*mspan <span class="comment">// all spans out there</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// spans is a lookup table to map virtual address page IDs to *mspan.</span></span><br><span class="line">    <span class="comment">// For allocated spans, their pages map to the span itself.</span></span><br><span class="line">    <span class="comment">// For free spans, only the lowest and highest pages map to the span itself.</span></span><br><span class="line">    <span class="comment">// Internal pages map to an arbitrary span.</span></span><br><span class="line">    <span class="comment">// For pages that have never been allocated, spans entries are nil.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is backed by a reserved region of the address space so</span></span><br><span class="line">    <span class="comment">// it can grow without moving. The memory up to len(spans) is</span></span><br><span class="line">    <span class="comment">// mapped. cap(spans) indicates the total reserved memory.</span></span><br><span class="line">    spans []*mspan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweepSpans contains two mspan stacks: one of swept in-use</span></span><br><span class="line">    <span class="comment">// spans, and one of unswept in-use spans. These two trade</span></span><br><span class="line">    <span class="comment">// roles on each GC cycle. Since the sweepgen increases by 2</span></span><br><span class="line">    <span class="comment">// on each cycle, this means the swept spans are in</span></span><br><span class="line">    <span class="comment">// sweepSpans[sweepgen/2%2] and the unswept spans are in</span></span><br><span class="line">    <span class="comment">// sweepSpans[1-sweepgen/2%2]. Sweeping pops spans from the</span></span><br><span class="line">    <span class="comment">// unswept stack and pushes spans that are still in-use on the</span></span><br><span class="line">    <span class="comment">// swept stack. Likewise, allocating an in-use span pushes it</span></span><br><span class="line">    <span class="comment">// on the swept stack.</span></span><br><span class="line">    sweepSpans [<span class="number">2</span>]gcSweepBuf</span><br><span class="line"></span><br><span class="line">    _ <span class="keyword">uint32</span> <span class="comment">// align uint64 fields on 32-bit for atomics</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proportional sweep</span></span><br><span class="line">    pagesInUse        <span class="keyword">uint64</span>  <span class="comment">// pages of spans in stats _MSpanInUse; R/W with mheap.lock</span></span><br><span class="line">    spanBytesAlloc    <span class="keyword">uint64</span>  <span class="comment">// bytes of spans allocated this cycle; updated atomically</span></span><br><span class="line">    pagesSwept        <span class="keyword">uint64</span>  <span class="comment">// pages swept this cycle; updated atomically</span></span><br><span class="line">    sweepPagesPerByte <span class="keyword">float64</span> <span class="comment">// proportional sweep ratio; written with lock, read without</span></span><br><span class="line">    <span class="comment">// TODO(austin): pagesInUse should be a uintptr, but the 386</span></span><br><span class="line">    <span class="comment">// compiler can't 8-byte align fields.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Malloc stats.</span></span><br><span class="line">    largefree  <span class="keyword">uint64</span>                  <span class="comment">// bytes freed for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    nlargefree <span class="keyword">uint64</span>                  <span class="comment">// number of frees for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    nsmallfree [_NumSizeClasses]<span class="keyword">uint64</span> <span class="comment">// number of frees for small objects (&lt;=maxsmallsize)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// range of addresses we might see in the heap</span></span><br><span class="line">    bitmap         <span class="keyword">uintptr</span> <span class="comment">// Points to one byte past the end of the bitmap</span></span><br><span class="line">    bitmap_mapped  <span class="keyword">uintptr</span></span><br><span class="line">    arena_start    <span class="keyword">uintptr</span></span><br><span class="line">    arena_used     <span class="keyword">uintptr</span> <span class="comment">// always mHeap_Map&#123;Bits,Spans&#125; before updating</span></span><br><span class="line">    arena_end      <span class="keyword">uintptr</span></span><br><span class="line">    arena_reserved <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// central free lists for small size classes.</span></span><br><span class="line">    <span class="comment">// the padding makes sure that the MCentrals are</span></span><br><span class="line">    <span class="comment">// spaced CacheLineSize bytes apart, so that each MCentral.lock</span></span><br><span class="line">    <span class="comment">// gets its own cache line.</span></span><br><span class="line">    central [_NumSizeClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spanalloc             fixalloc <span class="comment">// allocator for span*</span></span><br><span class="line">    cachealloc            fixalloc <span class="comment">// allocator for mcache*</span></span><br><span class="line">    specialfinalizeralloc fixalloc <span class="comment">// allocator for specialfinalizer*</span></span><br><span class="line">    specialprofilealloc   fixalloc <span class="comment">// allocator for specialprofile*</span></span><br><span class="line">    speciallock           mutex    <span class="comment">// lock for special record allocators.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mheap_ mheap</span><br></pre></td></tr></table></figure>
<p>mheap_ 是一个全局变量，会在系统初始化的时候初始化（在函数 mallocinit() 中）。我们先看一下 mheap 具体结构。</p>
<ul>
<li>allspans []*mspan: 所有的 spans 都是通过 mheap_ 申请，所有申请过的 mspan 都会记录在 allspans。结构体中的 lock 就是用来保证并发安全的。注释中有关于 STW 的说明，这个之后会在 Golang 的 GC 文章中细说。</li>
<li>central [_NumSizeClasses]…: 这个就是之前介绍的 mcentral ，每种大小的块对应一个 mcentral。mcentral 上面介绍过了。pad 可以认为是一个字节填充，为了避免伪共享（false sharing）问题的。</li>
<li>sweepgen, sweepdone: GC 相关。（Golang 的 GC 策略是 Mark &amp; Sweep, 这里是用来表示 sweep 的，这里就不再深入了。</li>
<li>free [_MaxMHeapList]mSpanList: 这是一个 SpanList 数组，每个 SpanList 里面的 mspan 由 1 ~ 127 (_MaxMHeapList - 1) 个 page 组成。比如 free[3] 是由包含 3 个 page 的 mspan 组成的链表。free 表示的是 free list，也就是未分配的。对应的还有 busy list。</li>
<li>freelarge mSpanList: mspan 组成的链表，每个元素（也就是 mspan）的 page 个数大于 127。对应的还有 busylarge。</li>
<li>spans []*mspan: 记录 arena 区域页号（page number）和 mspan 的映射关系。</li>
<li><p>arena_start, arena_end, arena_used: 要解释这几个变量之前要解释一下 arena。arena 是 Golang 中用于分配内存的连续虚拟地址区域。由 mheap 管理，堆上申请的所有内存都来自 arena。那么如何标志内存可用呢？操作系统的常见做法用两种：一种是用链表将所有的可用内存都串起来；另一种是使用位图来标志内存块是否可用。结合上面一条 spans，内存的布局是下面这样的。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+---------------------+-----------------------+</span><br><span class="line">|    spans              |    bitmap           |   arena               |</span><br><span class="line">+-----------------------+---------------------+-----------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>spanalloc, cachealloc fixalloc: fixalloc 是 free-list，用来分配特定大小的块。</p>
</li>
<li>剩下的是一些统计信息和 GC 相关的信息，这里暂且按住不表，以后专门拿出来说。</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在系统初始化阶段，上面介绍的几个结构会被进行初始化，我们直接看一下初始化代码：mallocinit()。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//一些系统检测代码，略去</span></span><br><span class="line">    <span class="keyword">var</span> p, bitmapSize, spansSize, pSize, limit <span class="keyword">uintptr</span></span><br><span class="line">    <span class="keyword">var</span> reserved <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit = runtime.memlimit();</span></span><br><span class="line">    <span class="comment">// See https://golang.org/issue/5049</span></span><br><span class="line">    <span class="comment">// TODO(rsc): Fix after 1.1.</span></span><br><span class="line">    limit = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//系统指针大小 PtrSize = 8，表示这是一个 64 位系统。</span></span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; (limit == <span class="number">0</span> || limit &gt; <span class="number">1</span>&lt;&lt;<span class="number">30</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的 arenaSize, bitmapSize, spansSize 分别对应 mheap 那一小节里面提到 arena 区大小，bitmap 区大小，spans 区大小。</span></span><br><span class="line">        arenaSize := round(_MaxMem, _PageSize)</span><br><span class="line">        bitmapSize = arenaSize / (sys.PtrSize * <span class="number">8</span> / <span class="number">2</span>)</span><br><span class="line">        spansSize = arenaSize / _PageSize * sys.PtrSize</span><br><span class="line">        spansSize = round(spansSize, _PageSize)</span><br><span class="line">        <span class="comment">//尝试从不同地址开始申请</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">0x7f</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">                p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span>:</span><br><span class="line">                p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            pSize = bitmapSize + spansSize + arenaSize + _PageSize</span><br><span class="line">            <span class="comment">//向 OS 申请大小为 pSize 的连续的虚拟地址空间</span></span><br><span class="line">            p = <span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))</span><br><span class="line">            <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是 32 位系统代码对应的操作，略去。</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    p1 := round(p, _PageSize)</span><br><span class="line"></span><br><span class="line">    spansStart := p1</span><br><span class="line">    mheap_.bitmap = p1 + spansSize + bitmapSize</span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// Set arena_start such that we can accept memory</span></span><br><span class="line">        <span class="comment">// reservations located anywhere in the 4GB virtual space.</span></span><br><span class="line">        mheap_.arena_start = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mheap_.arena_start = p1 + (spansSize + bitmapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    mheap_.arena_end = p + pSize</span><br><span class="line">    mheap_.arena_used = p1 + (spansSize + bitmapSize)</span><br><span class="line">    mheap_.arena_reserved = reserved</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mheap_.arena_start&amp;(_PageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"bad pagesize"</span>, hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), <span class="string">"start"</span>, hex(mheap_.arena_start))</span><br><span class="line">        throw(<span class="string">"misrounded allocation in mallocinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the rest of the allocator.</span></span><br><span class="line">    mheap_.init(spansStart, spansSize)</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.mcache = allocmcache()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面对代码做了简单的注释，下面详细解说其中的部分功能函数。</p>
<h4 id="arena-相关"><a href="#arena-相关" class="headerlink" title="arena 相关"></a>arena 相关</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arenaSize := round(_MaxMem, _PageSize)</span><br><span class="line">bitmapSize = arenaSize / (sys.PtrSize * <span class="number">8</span> / <span class="number">2</span>)</span><br><span class="line">spansSize = arenaSize / _PageSize * sys.PtrSize</span><br><span class="line">spansSize = round(spansSize, _PageSize)</span><br><span class="line"></span><br><span class="line">_MaxMem = <span class="keyword">uintptr</span>(<span class="number">1</span>&lt;&lt;_MHeapMap_TotalBits - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>首先解释一下变量 _MaxMem ，里面还有一个变量就不再列出来了。简单来说 _MaxMem 就是系统为 arena 区分配的大小：64 位系统分配 512 G；对于 Windows 64 位系统，arena 区分配 32 G。round 是一个对齐操作，向上取 _PageSize 的倍数。实现也很有意思，代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// round n up to a multiple of a.  a must be a power of 2.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">round</span><span class="params">(n, a <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap 用两个 bit 表示一个字的可用状态，那么算下来 bitmap 的大小为 16 G。读过 Golang 源码的同学会发现其实这段代码的注释里写的 bitmap 的大小为 32 G。其实是这段注释很久没有更新了，之前是用 4 个 bit 来表示一个字的可用状态，这真是一个悲伤的故事啊。</p>
<p>spans 记录的 arena 区的块页号和对应的 mspan 指针的对应关系。比如 arena 区内存地址 x，对应的页号就是 page_num = (x - arena_start) / page_size，那么 spans 就会记录 spans[page_num] = x。如果 arena 为 512 G的话，spans 区的大小为 512 G / 8K * 8 = 512 M。这里值得注意的是 Golang 的内存管理虚拟地址页大小为 8k。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageSize = <span class="number">1</span> &lt;&lt; _PageShift</span><br><span class="line"></span><br><span class="line">_PageShift = <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>所以这一段连续的的虚拟内存布局（64 位）如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+---------------------+-----------------------+</span><br><span class="line">|    spans 512M         |    bitmap 16G       |   arena 512           |</span><br><span class="line">+-----------------------+---------------------+-----------------------+</span><br></pre></td></tr></table></figure>
<h4 id="虚拟地址申请"><a href="#虚拟地址申请" class="headerlink" title="虚拟地址申请"></a>虚拟地址申请</h4><p>主要是下面这段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试从不同地址开始申请</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">0x7f</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">        p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span>:</span><br><span class="line">        p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pSize = bitmapSize + spansSize + arenaSize + _PageSize</span><br><span class="line">    <span class="comment">//向 OS 申请大小为 pSize 的连续的虚拟地址空间</span></span><br><span class="line">    p = <span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))</span><br><span class="line">    <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的时候，Golang 向操作系统申请一段连续的地址空间，就是上面的 spans + bitmap + arena。p 就是这段连续地址空间的开始地址，不同平台的 p 取值不一样。像 OS 申请的时候视不同的 OS 版本，调用不同的系统调用，比如 Unix 系统调用 mmap (mmap 想操作系统内核申请新的虚拟地址区间，可指定起始地址和长度)，Windows 系统调用 VirtualAlloc （类似 mmap）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsd</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; <span class="keyword">uint64</span>(n) &gt; <span class="number">1</span>&lt;&lt;<span class="number">32</span> || sys.GoosNacl != <span class="number">0</span> &#123;</span><br><span class="line">        *reserved = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(p) &lt; <span class="number">4096</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//darwin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(p) &lt; <span class="number">4096</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//linux</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(p) &lt; <span class="number">4096</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//windows</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// v is just a hint.</span></span><br><span class="line">    <span class="comment">// First try at v.</span></span><br><span class="line">    v = unsafe.Pointer(stdcall4(_VirtualAlloc, <span class="keyword">uintptr</span>(v), n, _MEM_RESERVE, _PAGE_READWRITE))</span><br><span class="line">    <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next let the kernel choose the address.</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(stdcall4(_VirtualAlloc, <span class="number">0</span>, n, _MEM_RESERVE, _PAGE_READWRITE))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-初始化"><a href="#mheap-初始化" class="headerlink" title="mheap 初始化"></a>mheap 初始化</h4><p>我们上面介绍 mheap 结构的时候知道 spans, bitmap, arena 都是存在于 mheap 中的，从操作系统申请完地址之后就是初始化 mheap 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    p1 := round(p, _PageSize)</span><br><span class="line"></span><br><span class="line">    spansStart := p1</span><br><span class="line">    mheap_.bitmap = p1 + spansSize + bitmapSize</span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// Set arena_start such that we can accept memory</span></span><br><span class="line">        <span class="comment">// reservations located anywhere in the 4GB virtual space.</span></span><br><span class="line">        mheap_.arena_start = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mheap_.arena_start = p1 + (spansSize + bitmapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    mheap_.arena_end = p + pSize</span><br><span class="line">    mheap_.arena_used = p1 + (spansSize + bitmapSize)</span><br><span class="line">    mheap_.arena_reserved = reserved</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mheap_.arena_start&amp;(_PageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"bad pagesize"</span>, hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), <span class="string">"start"</span>, hex(mheap_.arena_start))</span><br><span class="line">        throw(<span class="string">"misrounded allocation in mallocinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the rest of the allocator.</span></span><br><span class="line">    mheap_.init(spansStart, spansSize)</span><br><span class="line">    <span class="comment">//获取当前 G</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="comment">// 获取 G 上绑定的 M 的 mcache</span></span><br><span class="line">    _g_.m.mcache = allocmcache()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p 是从连续虚拟地址的起始地址，先进行对齐，然后初始化 arena，bitmap，spans 地址。mheap_.init()会初始化 fixalloc 等相关的成员，还有 mcentral 的初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">init</span><span class="params">(spansStart, spansBytes <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">    h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">    h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">    h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// h-&gt;mapcache needs no init</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.free &#123;</span><br><span class="line">        h.free[i].init()</span><br><span class="line">        h.busy[i].init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.freelarge.init()</span><br><span class="line">    h.busylarge.init()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">        h.central[i].mcentral.init(<span class="keyword">int32</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp := (*slice)(unsafe.Pointer(&amp;h.spans))</span><br><span class="line">    sp.array = unsafe.Pointer(spansStart)</span><br><span class="line">    sp.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">    sp.<span class="built_in">cap</span> = <span class="keyword">int</span>(spansBytes / sys.PtrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mheap 初始化之后，对当前的线程也就是 M 进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取当前 G</span><br><span class="line">_g_ := getg()</span><br><span class="line">// 获取 G 上绑定的 M 的 mcache</span><br><span class="line">_g_.m.mcache = allocmcache()</span><br></pre></td></tr></table></figure>
<h4 id="per-P-mcache-初始化"><a href="#per-P-mcache-初始化" class="headerlink" title="per-P mcache 初始化"></a>per-P mcache 初始化</h4><p>上面好像并没有说到针对 P 的 mcache 初始化，因为这个时候还没有初始化 P。我们看一下 bootstrap 的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mallocinit()</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> procs &gt; _MaxGomaxprocs &#123;</span><br><span class="line">        procs = _MaxGomaxprocs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mallocinit() 上面说过了。对 P 的初始化在函数 procresize() 中执行，我们下面只看内存相关的部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// initialize new P's</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            pp = <span class="built_in">new</span>(p)</span><br><span class="line">            pp.id = i</span><br><span class="line">            pp.status = _Pgcstop</span><br><span class="line">            pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">                pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// P mcache 初始化</span></span><br><span class="line">        <span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">                    throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// P[0] 分配给主 Goroutine</span></span><br><span class="line">                pp.mcache = getg().m.mcache <span class="comment">// bootstrap</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// P[0] 之外的 P 申请 mcache</span></span><br><span class="line">                pp.mcache = allocmcache()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 P 都存放在一个全局数组 allp 中，procresize() 的目的就是将 allp 中用到的 P 进行初始化，同时对多余 P 的资源剥离。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>先说一下给对象 object 分配内存的主要流程：</p>
<ul>
<li>ject size &gt; 32K，则使用 mheap 直接分配</li>
<li>object size &lt; 16 byte，使用 mcache 的小对象分配器 tiny 直接分配。 （其实 tiny 就是一个指针，暂且这么说吧</li>
<li>object size &gt; 16 byte &amp;&amp; size &lt;=32K byte 时，先使用 mcache 中对应的 size class 分配</li>
<li>如果 mcache 对应的 size class 的 span 已经没有可用的块，则向 mcentral 请求</li>
<li>如果 mcentral 也没有可用的块，则向 mheap 申请，并切分</li>
<li>如果 mheap 也没有合适的 span，则想操作系统申请</li>
</ul>
<p>我们看一下在堆上，也就是 arena 区分配内存的相关函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := foo()</span><br><span class="line">    <span class="built_in">println</span>(*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据之前介绍的逃逸分析，foo() 中的 x 会被分配到堆上。把上面代码保存为 test1.go 看一下汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &apos;-l&apos; -o test1 test1.go</span><br><span class="line">$ go tool objdump -s &quot;main\.foo&quot; test1</span><br><span class="line">TEXT main.foo(SB) /Users/didi/code/go/malloc_example/test2.go</span><br><span class="line">    test2.go:3  0x2040  65488b0c25a0080000  GS MOVQ GS:0x8a0, CX</span><br><span class="line">    test2.go:3  0x2049  483b6110        CMPQ 0x10(CX), SP</span><br><span class="line">    test2.go:3  0x204d  762a            JBE 0x2079</span><br><span class="line">    test2.go:3  0x204f  4883ec10        SUBQ $0x10, SP</span><br><span class="line">    test2.go:4  0x2053  488d1d66460500      LEAQ 0x54666(IP), BX</span><br><span class="line">    test2.go:4  0x205a  48891c24        MOVQ BX, 0(SP)</span><br><span class="line">    test2.go:4  0x205e  e82d8f0000      CALL runtime.newobject(SB)</span><br><span class="line">    test2.go:4  0x2063  488b442408      MOVQ 0x8(SP), AX</span><br><span class="line">    test2.go:4  0x2068  48c70001000000      MOVQ $0x1, 0(AX)</span><br><span class="line">    test2.go:5  0x206f  4889442418      MOVQ AX, 0x18(SP)</span><br><span class="line">    test2.go:5  0x2074  4883c410        ADDQ $0x10, SP</span><br><span class="line">    test2.go:5  0x2078  c3          RET</span><br><span class="line">    test2.go:3  0x2079  e8a28d0400      CALL runtime.morestack_noctxt(SB)</span><br><span class="line">    test2.go:3  0x207e  ebc0            JMP main.foo(SB)</span><br></pre></td></tr></table></figure>
<p>堆上内存分配调用了 runtime 包的 newobject 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    c := gomcache()</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.kind&amp;kindNoPointers != <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">        <span class="comment">// object size &lt;= 32K</span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">            <span class="comment">// 小于 16 byte 的小对象分配</span></span><br><span class="line">            off := c.tinyoffset</span><br><span class="line">            <span class="comment">// Align tiny pointer for required (conservative) alignment.</span></span><br><span class="line">            <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">8</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">4</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.local_tinyallocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line">            span := c.alloc[tinySizeClass]</span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, _, shouldhelpgc = c.nextFree(tinySizeClass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">            <span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">            <span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">                c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">                c.tinyoffset = size</span><br><span class="line">            &#125;</span><br><span class="line">            size = maxTinySize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// object size &gt;= 16 byte  &amp;&amp; object size &lt;= 32K byte</span></span><br><span class="line">            <span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">            <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">                sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">            &#125;</span><br><span class="line">            size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">            span := c.alloc[sizeclass]</span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(sizeclass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//object size &gt; 32K byte</span></span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            s = largeAlloc(size, needzero)</span><br><span class="line">        &#125;)</span><br><span class="line">        s.freeindex = <span class="number">1</span></span><br><span class="line">        s.allocCount = <span class="number">1</span></span><br><span class="line">        x = unsafe.Pointer(s.base())</span><br><span class="line">        size = s.elemsize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个分配过程可以根据 object size 拆解成三部分：size &lt; 16 byte, 16 byte &lt;= size &lt;= 32 K byte, size &gt; 32 K byte。</p>
<h5 id="size-小于-16-byte"><a href="#size-小于-16-byte" class="headerlink" title="size 小于 16 byte"></a>size 小于 16 byte</h5><p>对于小于 16 byte 的内存块，mcache 有个专门的内存区域 tiny 用来分配，tiny 是指针，指向开始地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">            off := c.tinyoffset</span><br><span class="line">            <span class="comment">// 地址对齐</span></span><br><span class="line">            <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">8</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">4</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分配</span></span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.local_tinyallocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tiny 不够了，为其重新分配一个 16 byte 内存块</span></span><br><span class="line">            span := c.alloc[tinySizeClass]</span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, _, shouldhelpgc = c.nextFree(tinySizeClass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            <span class="comment">//将申请的内存块全置为 0</span></span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">            <span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">            <span class="comment">// 如果申请的内存块用不完，则将剩下的给 tiny，用 tinyoffset 记录分配了多少。</span></span><br><span class="line">            <span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">                c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">                c.tinyoffset = size</span><br><span class="line">            &#125;</span><br><span class="line">            size = maxTinySize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，tinyoffset 表示 tiny 当前分配到什么地址了，之后的分配根据 tinyoffset 寻址。先根据要分配的对象大小进行地址对齐，比如 size 是 8 的倍数，tinyoffset 和 8 对齐。然后就是进行分配。如果 tiny 剩余的空间不够用，则重新申请一个 16 byte 的内存块，并分配给 object。如果有结余，则记录在 tiny 上。</p>
<h5 id="size-大于-32-K-byte"><a href="#size-大于-32-K-byte" class="headerlink" title="size 大于 32 K byte"></a>size 大于 32 K byte</h5><p>对于大于 32 Kb 的内存分配，直接跳过 mcache 和 mcentral，通过 mheap 分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            s = largeAlloc(size, needzero)</span><br><span class="line">        &#125;)</span><br><span class="line">        s.freeindex = <span class="number">1</span></span><br><span class="line">        s.allocCount = <span class="number">1</span></span><br><span class="line">        x = unsafe.Pointer(s.base())</span><br><span class="line">        size = s.elemsize</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeAlloc</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    npages := size &gt;&gt; _PageShift</span><br><span class="line">    <span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">        npages++</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    s := mheap_.alloc(npages, <span class="number">0</span>, <span class="literal">true</span>, needzero)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">"out of memory"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s.limit = s.base() + size</span><br><span class="line">    heapBitsForSpan(s.base()).initSpan(s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于大于 32 K 的内存分配都是分配整数页，先右移然后低位与计算需要的页数。</p>
<h5 id="size-介于-16-和-32K"><a href="#size-介于-16-和-32K" class="headerlink" title="size 介于 16 和 32K"></a>size 介于 16 和 32K</h5><p>对于 size 介于 16 ~ 32K byte 的内存分配先计算应该分配的 sizeclass，然后去 mcache 里面 alloc[sizeclass] 申请，如果 mcache.alloc[sizeclass] 不足以申请，则 mcache 向 mcentral 申请，然后再分配。mcentral 给 mcache 分配完之后会判断自己需不需要扩充，如果需要则想 mheap 申请。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//计算 sizeclass</span></span><br><span class="line">            <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">                sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-       <span class="number">1</span>)/largeSizeDiv]</span><br><span class="line">            &#125;</span><br><span class="line">            size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">            span := c.alloc[sizeclass]</span><br><span class="line">            <span class="comment">//从对应的 span 里面分配一个 object </span></span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(sizeclass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先看一下如何计算 sizeclass 的，预先定义了两个数组：size_to_class8 和 size_to_class128。 数组 size_to_class8，其第 i 个值表示地址区间 ( (i-1)<em>8, i</em>8 ] (smallSizeDiv = 8) 对应的 sizeclass，size_to_class128 类似。小于 1024 - 8 = 1016 （smallSizeMax=1024），使用 size_to_class8，否则使用数组 size_to_class128。看一下数组具体的值：0, 1, 2, 3, 3, 4, 4…。举个例子，比如要分配 17 byte 的内存 （16 byte 以下的使用 mcache.tiny 分配），sizeclass = size_to_calss8[(17+7)/8] = size_to_class8[3] = 3。不得不说这种用空间换时间的策略确实提高了运行效率。</p>
<p>计算出 sizeclass，那么就可以去 mcache.alloc[sizeclass] 分配了，注意这是一个 mspan 指针，真正的分配函数是 nextFreeFast() 函数。如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFreeFast returns the next free object if one is quickly available.</span></span><br><span class="line"><span class="comment">// Otherwise it returns 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">    theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line">    <span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">        result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line">        <span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">            freeidx := result + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            s.allocCache &gt;&gt;= (theBit + <span class="number">1</span>)</span><br><span class="line">            s.freeindex = freeidx</span><br><span class="line">            v := gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">            s.allocCount++</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allocCache 这里是用位图表示内存是否可用，1 表示可用。然后通过 span 里面的 freeindex 和 elemsize 来计算地址即可。</p>
<p>如果 mcache.alloc[sizeclass] 已经不够用了，则从 mcentral 申请内存到 mcache。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFree returns the next free object from the cached span if one is available.</span></span><br><span class="line"><span class="comment">// Otherwise it refills the cache with a span with an available object and</span></span><br><span class="line"><span class="comment">// returns that object along with a flag indicating that this was a heavy</span></span><br><span class="line"><span class="comment">// weight allocation. If it is a heavy weight allocation the caller must</span></span><br><span class="line"><span class="comment">// determine whether a new GC cycle needs to be started or if the GC is active</span></span><br><span class="line"><span class="comment">// whether this goroutine needs to assist the GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(sizeclass <span class="keyword">uint8</span>)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    s = c.alloc[sizeclass]</span><br><span class="line">    shouldhelpgc = <span class="literal">false</span></span><br><span class="line">    freeIndex := s.nextFreeIndex()</span><br><span class="line">    <span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">        <span class="comment">// The span is full.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"runtime: s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">            throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 这个地方 mcache 向 mcentral 申请</span></span><br><span class="line">            c.refill(<span class="keyword">int32</span>(sizeclass))</span><br><span class="line">        &#125;)</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        s = c.alloc[sizeclass]</span><br><span class="line">        <span class="comment">// mcache 向 mcentral 申请完之后，再次从 mcache 申请</span></span><br><span class="line">        freeIndex = s.nextFreeIndex()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextFreeIndex returns the index of the next free object in s at</span></span><br><span class="line"><span class="comment">// or after s.freeindex.</span></span><br><span class="line"><span class="comment">// There are hardware instructions that can be used to make this</span></span><br><span class="line"><span class="comment">// faster if profiling warrants it.</span></span><br><span class="line"><span class="comment">// 这个函数和 nextFreeFast 有点冗余了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">nextFreeIndex</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mcache 向 mcentral，如果 mcentral 不够，则向 mheap 申请。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">refill</span><span class="params">(sizeclass <span class="keyword">int32</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 向 mcentral 申请</span></span><br><span class="line">    s = mheap_.central[sizeclass].mcentral.cacheSpan()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a span to use in an MCache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replenish central list if empty.</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">grow</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    npages := <span class="keyword">uintptr</span>(class_to_allocnpages[c.sizeclass])</span><br><span class="line">    size := <span class="keyword">uintptr</span>(class_to_size[c.sizeclass])</span><br><span class="line">    n := (npages &lt;&lt; _PageShift) / size</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里想 mheap 申请</span></span><br><span class="line">    s := mheap_.alloc(npages, c.sizeclass, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 mheap 不足，则想 OS 申请。接上面的代码 mheap_.alloc()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, sizeclass <span class="keyword">int32</span>, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s = h.alloc_m(npage, sizeclass, large)</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, sizeclass <span class="keyword">int32</span>, large <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    s := h.allocSpanLocked(npage)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    s = h.allocLarge(npage)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = h.allocLarge(npage)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">grow</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// Ask for a big chunk, to reduce the number of mappings</span></span><br><span class="line">    <span class="comment">// the operating system needs to track; also amortizes</span></span><br><span class="line">    <span class="comment">// the overhead of an operating system mapping.</span></span><br><span class="line">    <span class="comment">// Allocate a multiple of 64kB.</span></span><br><span class="line">    npage = round(npage, (<span class="number">64</span>&lt;&lt;<span class="number">10</span>)/_PageSize)</span><br><span class="line">    ask := npage &lt;&lt; _PageShift</span><br><span class="line">    <span class="keyword">if</span> ask &lt; _HeapAllocChunk &#123;</span><br><span class="line">        ask = _HeapAllocChunk</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v := h.sysAlloc(ask)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个函数调用链如上所示，最后 sysAlloc 会调用系统调用（mmap 或者 VirtualAlloc，和初始化那部分有点类似）去向操作系统申请。</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>mcache 回收可以分两部分：第一部分是将 alloc 中未用完的内存归还给对应的 mcentral。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freemcache</span><span class="params">(c *mcache)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c.releaseAll()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        purgecachedstats(c)</span><br><span class="line">        mheap_.cachealloc.free(unsafe.Pointer(c))</span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">releaseAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; _NumSizeClasses; i++ &#123;</span><br><span class="line">        s := c.alloc[i]</span><br><span class="line">        <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">            mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">            c.alloc[i] = &amp;emptymspan</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clear tinyalloc pool.</span></span><br><span class="line">    c.tiny = <span class="number">0</span></span><br><span class="line">    c.tinyoffset = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 releaseAll() 负责将 mcache.alloc 中各个 sizeclass 中的 mspan 归还给 mcentral。这里需要注意的是归还给 mcentral 的时候需要加锁，因为 mcentral 是全局的。除此之外将剩下的 mcache （基本是个空壳）归还给 mheap.cachealloc，其实就是把 mcache 插入 free list 表头。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fixalloc)</span> <span class="title">free</span><span class="params">(p unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    f.inuse -= f.size</span><br><span class="line">    v := (*mlink)(p)</span><br><span class="line">    v.next = f.list</span><br><span class="line">    f.list = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcentral-回收"><a href="#mcentral-回收" class="headerlink" title="mcentral 回收"></a>mcentral 回收</h4><p>当 mspan 没有 free object 的时候，将 mspan 归还给 mheap。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">freeSpan</span><span class="params">(s *mspan, preserve <span class="keyword">bool</span>, wasempty <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> s.allocCount != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.nonempty.remove(s)</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    mheap_.freeSpan(s, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-1"><a href="#mheap-1" class="headerlink" title="mheap"></a>mheap</h4><p>mheap 并不会定时向操作系统归还，但是会对 span 做一些操作，比如合并相邻的 span。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>tcmalloc 是一种理论，运用到实践中还要考虑工程实现的问题。学习 Golang 源码的过程中，除了知道它是如何工作的之外，还可以学习到很多有趣的知识，比如使用变量填充 CacheLine 避免 False Sharing，利用 debruijn 序列求解 Trailing Zero（在函数中 sys.Ctz64 使用）等等。我想这就是读源码的意义所在吧。</p>
<blockquote>
<p>转载自<a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">http://legendtkl.com/2017/04/02/golang-alloc/</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/20/go-gc/" class="prev">PREV</a><a href="/2017/04/10/redis常用数据结构和操作/" class="next">NEXT</a></div><div id="gitalk-container"></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
    clientID: '0005895a71d0d3de1ae6',
    clientSecret: 'e8a1b830b9588e99b5369bcf5ca60778420aec55',
    repo: 'fitzix.github.io',
    owner: 'fitzix',
    admin: ['fitzix'],
    id: location.pathname.substring(1, 51),
    distractionFreeMode: false  // Facebook-like distraction free mode
});
gitalk.render('gitalk-container');</script><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/fitzix">fitzix</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/fitzix/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-137176691-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())
gtag('config', 'UA-137176691-1');</script></body></html>