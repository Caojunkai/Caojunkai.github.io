---
layout: go
title: channel底层原理
date: 2019-04-16 12:44:02
tags: [go, channel]
---

Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles在goroutine的通信和同步中承担着重要的角色。

<!--more-->

### channel的整体结构图

![](https://ws3.sinaimg.cn/large/b09f1c9dly1g24g49tkszj20oy0ipwgr.jpg)

- buf是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表
- sendx和recvx用于记录buf这个循环链表中的~发送或者接收的~index
- lock是个互斥锁
- recvq和sendq分别是接收(<-channel)或者发送(channel <- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表

源码位于/runtime/chan.go中(目前版本：1.11) 结构体为hchan

```go
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}
```

### 先从创建开始
创建一个channel
```go
ch := make(chan int, 3)
```

创建channel实际上就是在内存中实例化了一个hchan的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针




