<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Fitzix</title><meta name="description" content="Fitzix Hexo Bolg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/fitzix/atom.xml" title="Fitzix"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/14334411?s=460&amp;v=4" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fitzix" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/06/04/how_to_use_session_without_cookie/" class="post-title-link">禁用COOKIE后如何访问SESSION问题</a></h2><div class="tags"><a href="/tags/php/" class="tag-title">#php</a></div><div class="post-info">Jun 4, 2015</div><div class="post-content"><p>最近看到一个有关在PHP中使用COOKIE会话管理的面试题，不单单是因为这道题很有意思，还有就是自己以前确实没有想到过这个方面（<em>知识欠缺</em>:P），所以这里做个记录总结下，该题大概是这样描述的:</p>
<pre><code>如何不使用cookie向客户端发送一个cookie?
</code></pre><p>刚看到这道题时确实懵了，愣是没看懂，后面在网上搜索了下，猜测出题人的意图估计是想解决这样的一个场景：</p>
<pre><code>当客户端端禁用COOKIE时，如何在本地保存COOKIE以及在发送HTTP请求时带上COOKIE信息。
</code></pre></div><a href="/2015/06/04/how_to_use_session_without_cookie/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/05/13/pdo_bindParam_bug_note/" class="post-title-link">关于在PDO中使用bindParam绑定参数的陷阱</a></h2><div class="tags"><a href="/tags/php/" class="tag-title">#php</a></div><div class="post-info">May 13, 2015</div><div class="post-content"><p>今天，在看鸟哥<a href="http://weibo.com/laruence" target="_blank" rel="noopener">@laruence</a>的个人博客时看到了有关在PHP中使用PDO的bindParam绑定方法结合循环语句来使用时会产生一个<code>BUG</code>或者小陷阱，这里做个笔记备忘 :)</p>
<p>来自PHP官方的BUG报告在这里：<a href="https://bugs.php.net/bug.php?id=63281" target="_blank" rel="noopener">#63281</a></p></div><a href="/2015/05/13/pdo_bindParam_bug_note/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/04/20/yac_study_and_vs_memcache_note/" class="post-title-link">无锁共享内存---Yac</a></h2><div class="tags"><a href="/tags/php/" class="tag-title">#php</a></div><div class="post-info">Apr 20, 2015</div><div class="post-content"><p>这几天一直在研究鸟哥<a href="http://weibo.com/laruence" target="_blank" rel="noopener">@laruence</a>的一个产品—<strong>Yac</strong>，它是为PHP实现的一个基于共享内存、并且无锁的User Data Cache。今天比较了下Memcache和Yac的高并发读写性能测试，发现Yac要比Memcache快很多（这里没有比较Yac和Apc的性能情况, 不过据说Yac要比Apc快很多，Apc比Memcache快一倍，待有时间再进行测试吧, 好吧，承认懒了 ^_^)。</p></div><a href="/2015/04/20/yac_study_and_vs_memcache_note/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/04/18/xhprof_php_analyse_tool/" class="post-title-link">性能优化工具–-XHProf安装与使用</a></h2><div class="tags"><a href="/tags/php/" class="tag-title">#php</a></div><div class="post-info">Apr 18, 2015</div><div class="post-content"><p>XHProf是Facebook开源出来的一个PHP性能测试工具，他是一个轻量级的分析工具，跟xdebug差不多，但比 xdebug 分析的信息更加详细， 包括函数的调用次数，花费的时间（自身花费时间和包含内部函数花费的时间），所占内存/CPU，所占内存的峰值及所占百分比等，而xdebug对性能影响较大，即便是开启了<code>profiler_enable_trigger</code>参数，cpu也会立马飙到峰值。</p></div><a href="/2015/04/18/xhprof_php_analyse_tool/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/30/memcache_multiget_hole_note/" class="post-title-link">缓存无底洞现象</a></h2><div class="tags"><a href="/tags/Memcache/" class="tag-title">#Memcache</a></div><div class="post-info">Mar 30, 2015</div><div class="post-content"><p>该问题由facebook 的工作人员提出的, facebook 在2010 年左右,memcached 节点就已经达<br>3000 个,缓存数千G 内容.</p>
<p>他们发现了一个问题，即由于memcache连接频繁，导致效率下降了。于是他们开始添加memcache节点，添加新节点后，发现因为连接频繁导致的问题,仍然存在,并没有好转,称之为”<strong>无底洞现象</strong>”. 具体原文在这:<a href="http://highscalability.com/blog/2009/10/26/facebooks-memcached-multiget-hole-more-machinesmore-capacit.html" target="_blank" rel="noopener">Facebook Multiget Hole</a></p></div><a href="/2015/03/30/memcache_multiget_hole_note/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/29/memcache_item_delete_note/" class="post-title-link">Memcache过期数据惰性和LRU删除机制</a></h2><div class="tags"><a href="/tags/Memcache/" class="tag-title">#Memcache</a></div><div class="post-info">Mar 29, 2015</div><div class="post-content"><p>Memcache是缓存，所以数据不会永久保存在服务器上，这也是在服务器上引进Memcache的前提。当我们在memcache中存放数据时会设置超时时间（不设置，默认为永久有效，但不排除会被新数据剔除的可能性），那么当到达超时时间时memcache是如何做到删除数据的呢？这里需要引入<strong>Lazy Expiration</strong>即惰性失效的概念。  </p></div><a href="/2015/03/29/memcache_item_delete_note/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/29/memcache_perpetual_data_lose/" class="post-title-link">永久数据丢失现象</a></h2><div class="tags"><a href="/tags/Memcache/" class="tag-title">#Memcache</a></div><div class="post-info">Mar 29, 2015</div><div class="post-content"><p>有时候，在我们使用memcache过程中会出现”数据丢失”的现象， 也就是说明明数据被设为永久有效，却莫名其妙的丢失了，这是怎么回事呢？</p>
<p>在上一篇博客<a href="http://liyafeng.cn/memcache_item_delete_note/" target="_blank" rel="noopener">Memcache过期数据惰性和LRU删除机制</a>中已经总结了memcache过期数据是如何被删除的以及根据LRU（最近最少使用机制）来从最近未被使用的记录中搜索，并将其空间分配给新的记录。</p></div><a href="/2015/03/29/memcache_perpetual_data_lose/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/28/memcache_memory_manage_note/" class="post-title-link">Memcache的内存分配管理</a></h2><div class="tags"><a href="/tags/Memcache/" class="tag-title">#Memcache</a></div><div class="post-info">Mar 28, 2015</div><div class="post-content"><p>首先，我们要明白什么是<strong>内存的碎片化</strong>，要解释这个也不困难。大概可以这样描述，如果用c 语言直接<code>malloc</code>,<code>free</code> 来向操作系统申请和释放内存时,在不断的申请和释放过程中,形成了一些很小的内存片断,无法再利用.这种空闲,但无法利用内存的现象,即被称为<strong>内存的碎片化</strong>.</p></div><a href="/2015/03/28/memcache_memory_manage_note/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/20/mysql_and_slave_test/" class="post-title-link">MySQL数据库主从复制</a></h2><div class="tags"><a href="/tags/MySQL/" class="tag-title">#MySQL</a></div><div class="post-info">Mar 20, 2015</div><div class="post-content"><p>MySQL数据库主从复制的工作方式很简单，一台主机作为主服务器，一台或者多台主机作为从服务器。主服务器会把数据库的变化记录到日志，一旦这些变化被记录到日志，就会马上或者以固定的时间间隔被发送从服务器，使得主从服务器得到同步。</p>
<p>下面，总结下主从服务器配置原理，作为笔记，首先说明下测试环境（局域网内）：</p>
<pre><code>Centos 6.5 主 192.168.1.103 (VMware测试)
Centos 6.5 从 192.168.1.104 (VMware测试)
MySQL 5.4
</code></pre></div><a href="/2015/03/20/mysql_and_slave_test/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/07/winter_holiday_conclusion/" class="post-title-link">大学最后一个寒假</a></h2><div class="tags"><a href="/tags/Essay/" class="tag-title">#Essay</a></div><div class="post-info">Mar 7, 2015</div><div class="post-content"><p>猛地意识到今天就已经是3月7日了，而我买的是明天的火车票，对于我来说意味着毫无防备并且来不及拾掇就要滚回学校了。呜呼，时间过的真TM快，将近俩月的大学最后一个大长假就这么一睁眼一闭眼就嗝屁（方言）了,虽然到家没过一半时间就已经呆够了想回去，但此时此刻即将出发却也难免有恋家情节……</p>
<p>明天就要出发了，晚上简单收拾了下行李后就被母亲大人催促着早点睡觉，而对于一个习惯了熬夜的夜猫子来说很早睡觉真的不习惯，相信你懂得。于是打开笔记本，想看点东西却也没有了心思，干脆写点有感而发的东西也不错哦，算是这个寒假小结吧，说干就干，于是就有了下文 :)</p></div><a href="/2015/03/07/winter_holiday_conclusion/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="prev">PREV</a><a href="/page/4/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/fitzix">fitzix</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/fitzix/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-137176691-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())
gtag('config', 'UA-137176691-1');</script></body></html>