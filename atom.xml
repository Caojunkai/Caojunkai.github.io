<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fitzix</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/fitzix/"/>
  <updated>2019-04-23T04:52:59.710Z</updated>
  <id>https://github.com/fitzix/</id>
  
  <author>
    <name>fitzix</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go中interface的内存布局</title>
    <link href="https://github.com/fitzix/2019/03/19/Go%E4%B8%ADinterface%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>https://github.com/fitzix/2019/03/19/Go中interface的内存布局/</id>
    <published>2019-03-19T12:05:34.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对interface的底层结构及内存布局不了解，只是单纯的转换和使用。今天就遇到了关于interface内存布局的问题，没有答上来，查了查资料和源码，记录一下。</p><a id="more"></a><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>了解interface的内存结构是非常有必要的，只有了解了这一点，我们才能进一步分析诸如类型断言等情况的效率问题。先看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    String() <span class="keyword">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span>  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> strconv.FormatUint(i, <span class="number">10</span>))</span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint64</span>(i)  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := Binary&#123;&#125;  </span><br><span class="line">    s := Stringer(b)  </span><br><span class="line">    fmt.Print(s.String())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface在内存上实际由两个成员组成，如下图，tab指向虚表，data则指向实际引用的数据。虚表描绘了实际的类型信息及该接口所需要的方法集</p><p><img src="https://wx3.sinaimg.cn/large/b09f1c9dly1g28ahy06fij208x04dt8p.jpg" alt=""></p><p>观察itable的结构，首先是描述type信息的一些元数据，然后是满足Stringger接口的函数指针列表（注意，这里不是实际类型Binary的函数指针集哦）。 因此我们如果通过接口进行函数调用，实际的操作其实就是<code>s.tab-&gt;fun[0](s.data)</code>。 是不是和C++的虚表很像？接下来我们要看看golang的虚表和C++的虚表区别在哪里。</p><p>先看C++，它为每种类型创建了一个方法集，而它的虚表实际上就是这个方法集本身或是它的一部分而已，当面临多继承时（或者叫实现多个接口时，这是很常见的），C++对象结构里就会存在多个虚表指针，每个虚表指针指向该方法集的不同部分，因此，C++方法集里面函数指针有严格的顺序。 许多C++新手在面对多继承时就变得紧张，因为它的这种设计方式，为了保证其虚表能够正常工作，C++引入了很多概念，什么虚继承啊，接口函数同名问题啊，同一个接口在不同的层次上被继承多次的问题啊等等…… 就是老手也很容易因疏忽而写出问题代码出来。</p><p>我们再来看golang的实现方式，同C++一样，golang也为每种类型创建了一个方法集，不同的是接口的虚表是在运行时专门生成的。 可能细心的同学能够发现为什么要在运行时生成虚表。 因为太多了，每一种接口类型和所有满足其接口的实体类型的组合就是其可能的虚表数量，实际上其中的大部分是不需要的，因此golang选择在运行时生成它，例如，当例子中当首次遇见s := Stringer(b)这样的语句时，golang会生成Stringer接口对应于Binary类型的虚表，并将其缓存。</p><p>理解了golang的内存结构，再来分析诸如类型断言等情况的效率问题就很容易了，当判定一种类型是否满足某个接口时，golang使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型满足该接口。 例如某类型有$m$个方法，某接口有$n$个方法，则很容易知道这种判定的时间复杂度为$O(m \times n)$，不过可以使用预先排序的方式进行优化，实际的时间复杂度为$O(m+n)$。</p><h3 id="使用interface的注意事项"><a href="#使用interface的注意事项" class="headerlink" title="使用interface的注意事项"></a>使用interface的注意事项</h3><ul><li>对象赋值给接口变量时会复制该对象</li><li><p>接口使用的是一个名为iface的结构体存储的</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line"> tab  *itab <span class="comment">// 类型信息 </span></span><br><span class="line"> data unsafe.Pointer <span class="comment">// 实际对象指针 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line"> _type *_type</span><br><span class="line"> data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有接口变量内部的两个指针都为nil的时候，接口才等于nil</p></li><li>interface实际上是一个引用(只保存了两个值)，因此传递它并不会造成太多的损耗</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来对interface的底层结构及内存布局不了解，只是单纯的转换和使用。今天就遇到了关于interface内存布局的问题，没有答上来，查了查资料和源码，记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://github.com/fitzix/categories/Go/"/>
    
    
      <category term="Go" scheme="https://github.com/fitzix/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://github.com/fitzix/2018/12/26/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://github.com/fitzix/2018/12/26/Redis持久化/</id>
    <published>2018-12-26T02:38:42.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持久化是将程序数据在持久状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）</p></blockquote><a id="more"></a><h3 id="Redis的持久化方式"><a href="#Redis的持久化方式" class="headerlink" title="Redis的持久化方式"></a>Redis的持久化方式</h3><p>Redis有两种持久化方式：快照（RDB文件）和追加式文件（AOF文件）:</p><ul><li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照</li><li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存</li><li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里</li><li>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>Redis调用fork()，产生一个子进程</li><li>子进程把数据写到一个临时的RDB文件</li><li>当子进程写完新的RDB文件后，把旧的RDB文件替换掉</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本</li><li>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上</li><li>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作</li><li>比起AOF，在数据量比较大的情况下，RDB的启动速度更快</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了</li><li>RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒</li></ul><h4 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><p>默认Redis会把快照文件存储为当前目录下一个名为<code>dump.rdb</code>的文件。要修改文件的存储路径和名称，可以通过修改配置文件<code>redis.conf</code>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># RDB文件名，默认为dump.rdb。</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h4 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h4><p>你可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure><p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 格式为：save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># 可以设置多个。</span><br><span class="line">save 900 1 #900秒后至少1个key有变动</span><br><span class="line">save 300 10 #300秒后至少10个key有变动</span><br><span class="line">save 60 10000 #60秒后至少10000个key有变动</span><br></pre></td></tr></table></figure><p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，如果Redis在后台生成快照的时候失败，那么就会停止接收数据，目的是让用户能知道数据没有持久化成功。但是如果你有其他的方式可以监控到Redis及其持久化的状态，那么可以把这个功能禁止掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure><h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>默认Redis会采用LZF对数据进行压缩。如果你想节省点CPU的性能，你可以把压缩功能禁用掉，但是数据集就会比没压缩的时候要大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>从版本5的RDB的开始，一个<code>CRC64</code>的校验码会放在文件的末尾。这样更能保证文件的完整性，但是在保存或者加载文件时会损失一定的性能（大概10%）。如果想追求更高的性能，可以把它禁用掉，这样文件在写入校验码时会用<code>0</code>替代，加载的时候看到<code>0</code>就会直接跳过校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><h4 id="手动生成快照"><a href="#手动生成快照" class="headerlink" title="手动生成快照"></a>手动生成快照</h4><p>Redis提供了两个命令用于手动生成快照</p><ul><li><p>SAVE</p><p>  SAVE命令会使用同步的方式生成RDB快照文件，这意味着在这个过程中会阻塞所有其他客户端的请求。因此不建议在生产环境使用这个命令，除非因为某种原因需要去阻止Redis使用子进程进行后台生成快照（例如调用fork(2)出错</p></li><li><p>BGSAVE</p><p>  BGSAVE命令使用后台的方式保存RDB文件，调用此命令后，会立刻返回OK返回码。Redis会产生一个子进程进行处理并立刻恢复对客户端的服务。在客户端我们可以使用LASTSAVE命令查看操作是否成功</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br><span class="line">127.0.0.1:6379&gt; LASTSAVE</span><br><span class="line">(integer) 1553569206</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>配置文件里禁用了快照生成功能不影响SAVE和BGSAVE命令的效果</p></blockquote><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据</li><li>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用redis-check-aof这个工具很简单的进行修复</li><li>当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上</li><li>AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用FLUSHALL命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在相同的数据集下，AOF文件的大小一般会比RDB文件大</li><li>在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平</li></ul><h4 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h4><p>把配置项<code>appendonly</code>设为<code>yes</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line"># 文件存放目录，与RDB共用。默认为当前工作目录。</span><br><span class="line">dir ./</span><br><span class="line"># 默认文件名为appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>可以配置Redis调用fsync的频率，有三个选项:</p><ul><li><code>always</code> 每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全</li><li><code>everysec</code> 每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）</li><li><code>no</code> 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般</li></ul><blockquote><p>推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。</p></blockquote><h4 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h4><p>随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件</p><p>工作原理如下:</p><ul><li>Redis调用fork()，产生一个子进程</li><li>子进程把新的AOF写到一个临时文件里</li><li>主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全</li><li>当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里</li><li>Redis以原子方式将旧文件重命名为新文件，并开始将新数据附加到新文件中</li></ul><p>我们可以通过配置设置日志重写的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</span><br><span class="line"># 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</span><br><span class="line"># 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>要禁用自动的日志重写功能，我们可以把百分比设置为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 0</span><br></pre></td></tr></table></figure><blockquote><p>Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行BGREWRITEAOF这个命令</p></blockquote><h4 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h4><p>如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复:</p><ul><li>备份AOF文件</li><li><p>使用redis-check-aof命令修复原始的AOF文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix</span><br></pre></td></tr></table></figure></li><li><p>可以使用diff -u命令看下两个文件的差异</p></li><li>使用修复过的文件重启Redis服务</li></ul><h3 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h3><p>在Redis 2.0和Redis 2.2中执行此操作有不同的过程，Redis 2.2中更简单，并且根本不需要重新启动.这里只说Redis &gt;= 2.2版本的方式:</p><ul><li>备份一个最新的<code>dump.rdb</code>的文件，并把备份文件放在一个安全的地方</li><li><p>运行以下两条命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config set appendonly yes</span><br><span class="line">redis-cli config set save &quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>确保数据跟切换前一致</p></li><li>确保数据正确的写到AOF文件里</li></ul><blockquote><p>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式<br>记得对配置文件redis.conf进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效</p></blockquote><h3 id="备份Redis数据"><a href="#备份Redis数据" class="headerlink" title="备份Redis数据"></a>备份Redis数据</h3><p><strong>Make Sure to Backup Your Database</strong> 磁盘中断,云中的实例消失,等等问题都可能会发生,没有备份意味着数据有巨大的风险消失在/dev/null中<br>Redis非常适合数据备份，因为您可以在数据库运行时复制RDB文件<br>RDB一旦生成就永远不会被修改，在生成它时会使用临时名称并在最终新快照完成时仅使用rename(2)以原子方式重命名</p><p>建议的备份方法:</p><ul><li>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里</li><li>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照</li><li>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;持久化是将程序数据在持久状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://github.com/fitzix/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://github.com/fitzix/tags/Redis/"/>
    
      <category term="RDB" scheme="https://github.com/fitzix/tags/RDB/"/>
    
      <category term="AOF" scheme="https://github.com/fitzix/tags/AOF/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存淘汰策略</title>
    <link href="https://github.com/fitzix/2018/11/25/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <id>https://github.com/fitzix/2018/11/25/Redis内存淘汰策略/</id>
    <published>2018-11-25T06:58:19.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>当Redis被用作缓存的时候，当往Redis中添加新的数据，但是内存不足时，使用lru测试自动清除老的数据, 这几乎是所有缓存应用的默认特性. 事实上,LRU只是redis支持的淘汰策略的其中一种</p><a id="more"></a><h3 id="Maxmemory-configuration-directive"><a href="#Maxmemory-configuration-directive" class="headerlink" title="Maxmemory configuration directive"></a>Maxmemory configuration directive</h3><blockquote><p>maxmemory 100mb</p></blockquote><p>maxmemory用于配置redis使用的最大内存.将maxmemory设置为零会导致无内存限制,这是64位系统的默认行为，而32位系统则使用3GB的隐式内存限制.<br>当内存占用满时,Redis会根据不同的配置执行不同的淘汰策略,这时Redis可能会只返回会导致内存增长的命令的执行错误或者淘汰一些旧数据来添加新的数据.</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>使用<code>maxmemory-policy</code>来配置淘汰策略, redis的策略有以下几种:</p><ul><li>noeviction 禁止驱逐数据</li><li>allkeys-lru 从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>volatile-lru 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用 的数据淘汰</li><li>allkeys-random 从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>volatile-random 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据 淘汰</li><li>volatile-ttl 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数 据淘汰</li></ul><h3 id="Approximated-LRU-algorithm"><a href="#Approximated-LRU-algorithm" class="headerlink" title="Approximated LRU algorithm"></a>Approximated LRU algorithm</h3><p>redis使用的不是真正的lru算法。它使用的是近似的lru算法，通过抽样少量的keys，然后根据lru算法删除其中某个key。因此redis根据lru算法清除的key不一定是整个实例中”最近最少使用的”，而只是抽样中最近最少使用的.</p><p>redis 3.0开始redis的lru算法已经被改进了，提高了性能，更接近于真正的lru算法了。</p><h3 id="新的LFU模式"><a href="#新的LFU模式" class="headerlink" title="新的LFU模式"></a>新的LFU模式</h3><p>从Redis 4.0开始，可以使用新的最少使用的逐出模式。在某些情况下，这种模式可能效果更好（提供更好的命中/未命中率），因为使用LFU Redis将尝试追踪数据的访问频率，以便很少使用的数据被驱逐，而使用的数据往往有更高的机会被保留.</p><p>在LRU中,有些数据可能从未被访问,但由于随机性可能依然不会被清除.新的LFU将不会存在这个问题, 而且通常情况下可以适应不同的访问模式.</p><p>LFU的配置有以下两种:</p><ul><li>volatile-lfu</li><li>allkeys-lfu</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当Redis被用作缓存的时候，当往Redis中添加新的数据，但是内存不足时，使用lru测试自动清除老的数据, 这几乎是所有缓存应用的默认特性. 事实上,LRU只是redis支持的淘汰策略的其中一种&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://github.com/fitzix/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://github.com/fitzix/tags/Redis/"/>
    
      <category term="LRU" scheme="https://github.com/fitzix/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>AVL平衡二叉树中旋转</title>
    <link href="https://github.com/fitzix/2018/10/22/AVL%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%97%8B%E8%BD%AC/"/>
    <id>https://github.com/fitzix/2018/10/22/AVL平衡二叉树中旋转/</id>
    <published>2018-10-22T05:49:13.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试被问到平衡二叉树如何保证平衡即失衡后是如何调整的, 之前也只是在leetcode上做过判断是否为平衡二叉树和树的深度搜索之类的题目,对AVL保证平衡的旋转方法及实现并不不了解,所以答不上来.回去后仔细了解了下,记录一下.</p><a id="more"></a><h2 id="AvlTree的定义"><a href="#AvlTree的定义" class="headerlink" title="AvlTree的定义"></a>AvlTree的定义</h2><p>AVL (Adelson Velskii和 Landis)树是带有平衡条件的二叉查找树。这个平衡条件必须容易保持，而且它必须保证树的深度是O(log N). 最简单的想法是要求左右子树具有相同的高度.</p><p>一般限制为：一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树(空树的高度定义为-1，树中叶子的高度为0，往根上递增).</p><h2 id="插入操作的问题"><a href="#插入操作的问题" class="headerlink" title="插入操作的问题"></a>插入操作的问题</h2><p>在对AVL树进行插入操作的时候,隐含的困难在于,插入一个节点可能破坏AVL树的平衡特性.</p><p>所以一般发生这种情况，我们需要把AVL树的平衡性质恢复之后才能算是插入这一步骤完成。事实上，我们只需要根据树的实际结构进行几种简单的旋转（rotation）操作就可以让树恢复AVL树的平衡性质。</p><h2 id="四种旋转的情况"><a href="#四种旋转的情况" class="headerlink" title="四种旋转的情况"></a>四种旋转的情况</h2><p>若平衡二叉树种某个结点的左子树和右子树的高度相差大于1，该树就是失衡了，该结点称为失衡点，就要通过旋转来保持二叉树的平衡</p><p>一共分四种情况导致结点失衡：</p><ul><li>在结点的左孩子的左子树中插入数据（LL）</li><li>在结点的左孩子的右子树中插入数据（LR）</li><li>在结点的右孩子的左子树中插入数据（RL）</li><li>在结点的右孩子的右子树中插入数据（RR)</li></ul><p>第1和4种情况是对称的，可用单旋来解决，而第2和3种情况也是对称的，要用双旋来解决</p><h3 id="LL型（左孩子的左子树）通过右旋解决"><a href="#LL型（左孩子的左子树）通过右旋解决" class="headerlink" title="LL型（左孩子的左子树）通过右旋解决"></a>LL型（左孩子的左子树）通过右旋解决</h3><p>对于LL型的情况，要使用右旋来解决，将失衡点右旋到其左孩子的右孩子的位置，失衡点的左子树更新为其原来左孩子的右子树</p><p><img src="https://wx2.sinaimg.cn/large/b09f1c9dly1g1bkynzhsgj20dw051jrj.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/b09f1c9dly1g1bl1qxnv3j20m806w0t1.jpg" alt=""></p><h3 id="RR型（右孩子的右子树）通过左旋解决"><a href="#RR型（右孩子的右子树）通过左旋解决" class="headerlink" title="RR型（右孩子的右子树）通过左旋解决"></a>RR型（右孩子的右子树）通过左旋解决</h3><p>对于RR型的情况，要使用左旋来解决，将失衡点左旋到其右孩子的左孩子的位置，失衡点的右子树更新为其原来右孩子的左子树</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g1bl2a76tgj20dw055mxc.jpg" alt=""><br><img src="https://wx1.sinaimg.cn/large/b09f1c9dly1g1bl2m1vxtj20m807r0t1.jpg" alt=""></p><h3 id="LR型（左孩子的右子树）通过先左旋再右旋解决"><a href="#LR型（左孩子的右子树）通过先左旋再右旋解决" class="headerlink" title="LR型（左孩子的右子树）通过先左旋再右旋解决"></a>LR型（左孩子的右子树）通过先左旋再右旋解决</h3><p>对于LR型的情况，要使用先对失衡点的左孩子进行左旋，然后再对失衡点进行右旋来解决</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g1bl36bhifj20f704fabj.jpg" alt=""><br><img src="https://wx3.sinaimg.cn/large/b09f1c9dly1g1bl3eseehj20m806owez.jpg" alt=""></p><h3 id="RL型（右孩子的左子树）通过先右旋再左旋解决"><a href="#RL型（右孩子的左子树）通过先右旋再左旋解决" class="headerlink" title="RL型（右孩子的左子树）通过先右旋再左旋解决"></a>RL型（右孩子的左子树）通过先右旋再左旋解决</h3><p>对于RL型的情况，要使用先对失衡点的右孩子进行右旋，然后再对失衡点进行左旋来解决</p><p><img src="https://wx2.sinaimg.cn/large/b09f1c9dly1g1bl3t68fhj20fm04tq4j.jpg" alt=""><br><img src="https://wx1.sinaimg.cn/large/b09f1c9dly1g1bl3yeruzj20m806fmxo.jpg" alt=""></p><blockquote><p>以上图片来自 <a href="https://segmentfault.com/a/1190000006123188#articleHeader6" target="_blank" rel="noopener">AVL平衡二叉树详解与实现</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试被问到平衡二叉树如何保证平衡即失衡后是如何调整的, 之前也只是在leetcode上做过判断是否为平衡二叉树和树的深度搜索之类的题目,对AVL保证平衡的旋转方法及实现并不不了解,所以答不上来.回去后仔细了解了下,记录一下.&lt;/p&gt;
    
    </summary>
    
      <category term="Tree" scheme="https://github.com/fitzix/categories/Tree/"/>
    
    
      <category term="AVL" scheme="https://github.com/fitzix/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>channel底层原理</title>
    <link href="https://github.com/fitzix/2018/08/16/channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/fitzix/2018/08/16/channel底层原理/</id>
    <published>2018-08-16T04:44:02.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles在goroutine的通信和同步中承担着重要的角色。</p><a id="more"></a><h2 id="channel的整体结构图"><a href="#channel的整体结构图" class="headerlink" title="channel的整体结构图"></a>channel的整体结构图</h2><p><img src="https://ws3.sinaimg.cn/large/b09f1c9dly1g24g49tkszj20oy0ipwgr.jpg" alt=""></p><ul><li>buf是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表</li><li>sendx和recvx用于记录buf这个循环链表中的~发送或者接收的~index</li><li>lock是个互斥锁</li><li>recvq和sendq分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><p>源码位于/runtime/chan.go中(目前版本：1.11) 结构体为hchan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="keyword">uint16</span></span><br><span class="line">closed   <span class="keyword">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先从创建开始"><a href="#先从创建开始" class="headerlink" title="先从创建开始"></a>先从创建开始</h2><p>创建一个channel<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>创建channel实际上就是在内存中实例化了一个hchan的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针</p><h3 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收"></a>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收</h3><p>先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？ 加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁mutex</p><h4 id="channel中队列是如何实现的"><a href="#channel中队列是如何实现的" class="headerlink" title="channel中队列是如何实现的"></a>channel中队列是如何实现的</h4><p>channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。 还是刚才创建的那个channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="https://wx1.sinaimg.cn/large/b09f1c9dly1g24hm3v1q2j20m80goabf.jpg" alt=""></p><p>当使用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候，首先要锁住hchan这个结构体。</p><p><img src="https://wx3.sinaimg.cn/large/b09f1c9dly1g24hrd009zj20m80gowf6.jpg" alt=""></p><p>然后开始send (ch &lt;- xx)数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>队列塞不进去了 动态图表示为:</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g24hsjihb5g20m80got9a.gif" alt=""></p><p>然后是取recv ( &lt;-ch)的过程，是个逆向的操作，也是需要加锁。</p><p><img src="https://ws4.sinaimg.cn/large/b09f1c9dly1g24htditfzj20m80got9q.jpg" alt=""></p><p>然后开始recv (&lt;-ch)数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br><span class="line">&lt;-ch</span><br><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p><img src="https://wx1.sinaimg.cn/large/b09f1c9dly1g24hur7e1vg20m80gojry.gif" alt=""></p><p>注意以上两幅图中buf和recvx以及sendx的变化，recvx和sendx是根据循环链表buf的变动而改变的。<br>至于为什么channel会使用循环链表作为缓存结构，我个人认为是在缓存列表在动态的send和recv过程中，定位当前send或者recvx的位置、选择send的和recvx的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。  </p><p>缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。</p><h4 id="send-recv的细化操作"><a href="#send-recv的细化操作" class="headerlink" title="send/recv的细化操作"></a>send/recv的细化操作</h4><p>缓存链表中以上每一步的操作，都是需要加锁操作的！<br>每一步的操作的细节可以细化为：</p><ul><li>加锁</li><li>把数据从goroutine中copy到“队列”中(或者从队列中copy到goroutine中）</li><li>释放锁</li></ul><p>每一步的操作总结为动态图为：(发送过程)</p><p><img src="https://ws2.sinaimg.cn/large/b09f1c9dly1g24hxrj6n4g20m80got9l.gif" alt=""></p><p>接收过程</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g24hy8pegxg20m80go3zg.gif" alt=""></p><p>所以不难看出，Go中那句经典的话：<code>Do not communicate by sharing memory; instead, share memory by communicating.</code>的具体实现就是利用channel把数据从一端copy到了另一端！<br>还真是符合channel的英文含义：</p><p><img src="https://wx2.sinaimg.cn/large/b09f1c9dly1g24hz09s7kg20m80go74v.gif" alt=""></p><h4 id="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"><a href="#当channel缓存满了之后会发生什么？这其中的原理是怎样的？" class="headerlink" title="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"></a>当channel缓存满了之后会发生什么？这其中的原理是怎样的？</h4><p>使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &lt;- xxx)或者recv(&lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？</p><p>我们知道，Go的goroutine是用户态的线程(user-space threads)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看另一篇文章(<a href="https://fitzix.github.io/2019/01/10/Goroutine%E7%9A%84%E8%B0%83%E5%BA%A6/" target="_blank" rel="noopener">Goroutine的调度</a>)</p><p>goroutine的阻塞操作，实际上是调用send (ch &lt;- xx)或者recv ( &lt;-ch)的时候主动触发的，具体请看以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goroutine1 中，记做G1</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://wx2.sinaimg.cn/large/b09f1c9dly1g24i38jrwuj20m80goq41.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g24i3hgvzbj20m80goabk.jpg" alt=""></p><p>这个时候G1正在正常运行,当再次进行send操作(ch&lt;-1)的时候，会主动调用Go的调度器,让G1等待，并让出M，让其他G去使用</p><p><img src="https://wx4.sinaimg.cn/large/b09f1c9dly1g24i4ztmzyj20m80gotc5.jpg" alt=""></p><p>同时G1也会被抽象成含有G1指针和send元素的sudog结构体保存到hchan的sendq中等待被唤醒。</p><p><img src="https://wx4.sinaimg.cn/large/b09f1c9dly1g24i5v4k3kg20m80go3zu.gif" alt=""></p><p>那么，G1什么时候被唤醒呢？这个时候G2隆重登场。</p><p><img src="https://ws2.sinaimg.cn/large/b09f1c9dly1g24i7hnwndj20m80gogmw.jpg" alt=""></p><p>G2执行了recv操作p := &lt;-ch，于是会发生以下的操作：</p><p><img src="https://wx2.sinaimg.cn/large/b09f1c9dly1g24i7sel6gg20m80godhw.gif" alt=""></p><p>G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g24i8qxueig20m80gogmj.gif" alt=""></p><p>假如是先进行执行recv操作的G2会怎么样？</p><p><img src="https://wx4.sinaimg.cn/large/b09f1c9dly1g24iafv9ipj20m80go41h.jpg" alt=""></p><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的sudog结构体保存到hchan的recvq中等待被唤醒</p><p><img src="https://wx4.sinaimg.cn/large/b09f1c9dly1g24iaxmr7ag20m80go0tt.gif" alt=""></p><p>此时恰好有个goroutine G1开始向channel中推送数据 ch &lt;- 1。 此时，非常有意思的事情发生了：</p><p><img src="https://wx1.sinaimg.cn/large/b09f1c9dly1g24ibc8cs3g20m80gojst.gif" alt=""></p><p>G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><p>之后的事情显而易见</p><p><img src="https://ws4.sinaimg.cn/large/b09f1c9dly1g24iprdqb9g20m80go757.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles在goroutine的通信和同步中承担着重要的角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://github.com/fitzix/tags/go/"/>
    
      <category term="channel" scheme="https://github.com/fitzix/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Goroutine的调度</title>
    <link href="https://github.com/fitzix/2018/06/10/Goroutine%E7%9A%84%E8%B0%83%E5%BA%A6/"/>
    <id>https://github.com/fitzix/2018/06/10/Goroutine的调度/</id>
    <published>2018-06-10T05:57:57.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对Go internals的都不了解,面试也经常会遇到goroutine的调度问题,当时并不是很清楚,回来以后查阅资料,现整理出来备忘.</p><a id="more"></a><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>操作系统中的线程分为两种：</p><ul><li>内核线程</li><li>用户线程</li></ul><p>用户平时使用的线程并不是内核线程，而是存在于用户态的用户线程<br>用户线程并不一定在操作系统内核中对用同等数量的内核线程。这里有三个模型：</p><ul><li>一对一模型(1:1)</li><li>多对一模型(N:1)</li><li>多对多模型(N:M)</li></ul><p>下面就先来谈谈这三种线程模型</p><h4 id="一对一模型-1-1"><a href="#一对一模型-1-1" class="headerlink" title="一对一模型(1:1)"></a>一对一模型(1:1)</h4><p>对于支持线程的操作系统来说，一对一模型是最简单的一种线程模型了，一个用户线程唯一对应一个内核线程，但反过来却不一定，一个内核线程并不一定有对应的用户线程存在。这样一来，由于一个内核线程至多只对应一个用户线程，线程之间可以做到最大程度的并发，不同线程之间不会相互影响，比如一个线程阻塞了也不会影响到其他线程的执行。对于多处理器，一对一的线程模型效率更高。但是很多操作系统限制了内核线程的数量，如果采用一对一模型，用户线程的数量也会受到比较大的限制。而且很多操作系统的内核线程在调度时开销较大，这也会影响用户线程的效率</p><h4 id="多对一模型-N-1"><a href="#多对一模型-N-1" class="headerlink" title="多对一模型(N:1)"></a>多对一模型(N:1)</h4><p>多对一模型意味着多个用户线程对应一个内核线程，用户线程间的切换由代码控制，因为线程间切换的效率比较高(不用陷入内核区去切换)。不过如果其中一个用户线程阻塞了，则和它对应相同内核线程的那些用户线程也都会阻塞，因为内核线程是被共用的(且是绑定的)，此时它无法抽身出来。而且增加处理器个数对于多对一线程模型帮助也不大，毕竟在这种情况下，一个线程阻塞，相关线程也跟着遭殃的事实和处理器个数关系不大。这种模型的好处是线程间切换开销低，且线程数量可以很多</p><h4 id="多对多模型-N-M"><a href="#多对多模型-N-M" class="headerlink" title="多对多模型(N:M)"></a>多对多模型(N:M)</h4><p>多对多线程模型可以说是上面两种模型的结合，也是最复杂的，它把多个用户线程对应到多个内核线程上，且很多时候不是唯一绑定的。因此一个内核线程在一个时间点可以对应0到多个用户线程。且在运行期间，系统可以根据线程执行情况做合理分配。比如用户线程1、用户线程2和用户线程3对应到一个内核线程1，如果用户线程1阻塞了，系统可以调度用户线程2和用户线程3到其他内核线程上去，这是个动态的过程。多对多线程模型的优势是可以让系统资源得到比较均衡的使用，用户线程之间互相影响比较小，且在多处理器上表现不错(虽然增加处理器个数对它性能提升可能不如一对一模型那么高)，关键是它很灵活</p><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>Go的运行时管理着调度、垃圾回收以及goroutine的运行环境<br>Golang的goroutine调度和多对多模型密切相关，Golang自己有自己的调度器scheduler。Golang的调度器内部有三个重要结构：M、P和G</p><p><img src="https://wx2.sinaimg.cn/large/b09f1c9dly1g1g6jo35klj20av02v3yc.jpg" alt=""></p><p>M: 代表内核线程<br>G: 代表一个goroutine，它有自己的栈，指令指针和一些基本信息，用于被调度<br>P: 代表调度的上下文，是Golang内部的调度器，负责让多个goroutine在一个内核线程上运行，它实现了N:1到N:M</p><h4 id="M、P-和-G-之间的交互"><a href="#M、P-和-G-之间的交互" class="headerlink" title="M、P 和 G 之间的交互"></a>M、P 和 G 之间的交互</h4><p><img src="https://ws2.sinaimg.cn/large/b09f1c9dly1g1g6w1iy1aj20zk0mxdgx.jpg" alt=""></p><p>可以看到，Go运行时存在两种类型的queue： 一种是一个全局的queue(在schedt结构体中，很少用到)， 一种是每个P都维护自己的G的queue<br>为了运行goroutine, M需要持有上下文P。M会从P的queue弹出一个goroutine并执行<br>当你创建一个新的goroutine的时候(go func()方法)，它会被放入P的queue。当然还有一个 work-stealing调度算法，当M执行了一些G后,如果它的queue为空，它会随机的选择另外一个P,从它的queue中取走一半的G到自己的queue中执行<br>当你的goroutine执行阻塞的系统调用的时候(syscall)，阻塞的系统调用会中断(intercepted)，如果当前有一些G在执行，运行时会把这个线程从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果没有空闲的线程可用的话)来服务于这个P<br>当系统调用继续的时候，这个goroutine被放入到本地运行queue，线程会park它自己(休眠)， 加入到空闲线程中<br>如果一个goroutine执行网络调用，运行时会做类似的动作。调用会被中断，但是由于Go使用集成的network poller,它有自己的线程，所以还给它<br>Go运行时会在下面的goroutine被阻塞的情况下运行另外一个goroutine：</p><ul><li>blocking syscall (for example opening a file)</li><li>network input</li><li>channel operations</li><li>primitives in the sync package</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="https://wx3.sinaimg.cn/large/b09f1c9dly1g1g6oe16rjj20b40avglr.jpg" alt=""></p><p>可以看到在某个时刻，一个M对应到一个P，一个P上有一个正在运行的G(蓝色的G)，且这个P上可能还有多个G等待被调度(灰色的G)，P维护着这个调度队列(runqueue)。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。不过需要注意，GOMAXPROCS()的最大值是256。当要启动一个goroutine时，只需要用go function(args)即可，一但我们启动了一个goroutine，就会在runqueue队尾加入这个goroutine，P会负责调度这些goroutine</p><p>那么如果在某个M被阻塞了呢？这时候就是N:M模型的关键之处了，此时P可以被安排到其他M上去执行，由于P内部维护着一些G的信息，这些G都有独立的栈和指令指针这些基本信息，所以可以很方便地直接换到另一个未被阻塞的M下</p><p><img src="https://ws4.sinaimg.cn/large/b09f1c9dly1g1g6pkk8b5j20fa0b474h.jpg" alt=""></p><p>上图描述了这种情况，在左边，G0正在运行，当G0由于系统调用被阻塞时，调度器会创建或者从线程缓存中取得一个线程M1，转投M1。当G0返回时，它必须获得一个P来执行，此时一般是先查看系统中有没有空闲的P，如果有，就获得一个P，用这个P来执行，如果没能获得一个P，这个G0只能暂时放置到一个全局的执行队列(global runqueue)中，它所处的线程M0也就sleep了。系统中的P们会周期性地检查这个队列，取出里面的G来运行</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g1g6spvu3jj20fa0b40sx.jpg" alt=""></p><p>如上图，还有一种情况是，某个M上的P被分配的G很快就被执行完了，这时M和P都处于闲置状态，无事可做。但也不可能看着其他的P忙碌自己不帮忙吧，此时会先去global runqueue中检查是否有G可以拿，如果并没有，只好尝试去其他P上“偷”一些G来执行，一般就是偷对方runqueue大小的一半，如果还是没偷到，那该只好sleep，该P放入一个闲置的P队列结构等待再次被调度</p><p>这样处理，就保证了系统中的G能被有效快速地执行，充分利用了系统资源</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来对Go internals的都不了解,面试也经常会遇到goroutine的调度问题,当时并不是很清楚,回来以后查阅资料,现整理出来备忘.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go文件操作</title>
    <link href="https://github.com/fitzix/2018/04/17/go-file-system-method/"/>
    <id>https://github.com/fitzix/2018/04/17/go-file-system-method/</id>
    <published>2018-04-16T16:01:16.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>Go官方库的文件操作分散在多个包中，比如<code>os</code>、<code>ioutil</code>包,发现已经有人2015年已经写了一篇这样的文章，写的非常好，我经常在需要使用文件方法的时候回过来查,所以翻译成了中文，记录一下.<br>原文<a href="https://www.devdungeon.com/content/working-files-go#write_bytes" target="_blank" rel="noopener"> Working with Files in Go</a>, 作者<a href="https://www.devdungeon.com/blogs/nanodano" target="_blank" rel="noopener"> NanoDano</a></p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="万物皆文件"><a href="#万物皆文件" class="headerlink" title="万物皆文件"></a>万物皆文件</h4><p>UNIX 的一个基础设计就是”万物皆文件”(everything is a file)。我们不必知道一个文件到底映射成什么，操作系统的设备驱动抽象成文件。操作系统为设备提供了文件格式的接口<br>Go语言中的reader和writer接口也类似。我们只需简单的读写字节，不必知道reader的数据来自哪里，也不必知道writer将数据发送到哪里。<br>你可以在<code>/dev</code>下查看可用的设备，有些可能需要较高的权限才能访问。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote><p>创建空文件</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    newFile *os.File</span><br><span class="line">    err     error</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newFile, err = os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(newFile)</span><br><span class="line">    newFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Truncate文件</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 裁剪一个文件到100个字节。</span></span><br><span class="line">    <span class="comment">// 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。</span></span><br><span class="line">    <span class="comment">// 如果文件本来超过100个字节，则超过的字节会被抛弃。</span></span><br><span class="line">    <span class="comment">// 这样我们总是得到精确的100个字节的文件。</span></span><br><span class="line">    <span class="comment">// 传入0则会清空文件。</span></span><br><span class="line">    err := os.Truncate(<span class="string">"test.txt"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>得到文件信息</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在，则返回错误</span></span><br><span class="line">    fileInfo, err = os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"File name:"</span>, fileInfo.Name())</span><br><span class="line">    fmt.Println(<span class="string">"Size in bytes:"</span>, fileInfo.Size())</span><br><span class="line">    fmt.Println(<span class="string">"Permissions:"</span>, fileInfo.Mode())</span><br><span class="line">    fmt.Println(<span class="string">"Last modified:"</span>, fileInfo.ModTime())</span><br><span class="line">    fmt.Println(<span class="string">"Is Directory: "</span>, fileInfo.IsDir())</span><br><span class="line">    fmt.Printf(<span class="string">"System interface type: %T\n"</span>, fileInfo.Sys())</span><br><span class="line">    fmt.Printf(<span class="string">"System info: %+v\n\n"</span>, fileInfo.Sys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重命名和移动</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalPath := <span class="string">"test.txt"</span></span><br><span class="line">    newPath := <span class="string">"test2.txt"</span></span><br><span class="line">    err := os.Rename(originalPath, newPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除文件</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Remove(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打开和关闭文件</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 简单地以只读的方式打开。下面的例子会介绍读写的例子。</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// OpenFile提供更多的选项。</span></span><br><span class="line">    <span class="comment">// 最后一个参数是权限模式permission mode</span></span><br><span class="line">    <span class="comment">// 第二个是打开时的属性    </span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 下面的属性可以单独使用，也可以组合使用。</span></span><br><span class="line">    <span class="comment">// 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：</span></span><br><span class="line">    <span class="comment">// os.O_CREATE|os.O_APPEND</span></span><br><span class="line">    <span class="comment">// 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY</span></span><br><span class="line">    <span class="comment">// os.O_RDONLY // 只读</span></span><br><span class="line">    <span class="comment">// os.O_WRONLY // 只写</span></span><br><span class="line">    <span class="comment">// os.O_RDWR // 读写</span></span><br><span class="line">    <span class="comment">// os.O_APPEND // 往文件中添建（Append）</span></span><br><span class="line">    <span class="comment">// os.O_CREATE // 如果文件不存在则先创建</span></span><br><span class="line">    <span class="comment">// os.O_TRUNC // 文件打开时裁剪文件</span></span><br><span class="line">    <span class="comment">// os.O_EXCL // 和O_CREATE一起使用，文件不能存在</span></span><br><span class="line">    <span class="comment">// os.O_SYNC // 以同步I/O的方式打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查文件是否存在</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo *os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在则返回error</span></span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            log.Fatal(<span class="string">"File does not exist."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"File does exist. File information:"</span>)</span><br><span class="line">    log.Println(fileInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查读写权限</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子测试写权限，如果没有写权限则返回error。</span></span><br><span class="line">    <span class="comment">// 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Write permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 测试读权限</span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Read permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改变权限、拥有者、时间戳</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Linux风格改变文件权限</span></span><br><span class="line">    err := os.Chmod(<span class="string">"test.txt"</span>, <span class="number">0777</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变文件所有者</span></span><br><span class="line">    err = os.Chown(<span class="string">"test.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变时间戳</span></span><br><span class="line">    twoDaysFromNow := time.Now().Add(<span class="number">48</span> * time.Hour)</span><br><span class="line">    lastAccessTime := twoDaysFromNow</span><br><span class="line">    lastModifyTime := twoDaysFromNow</span><br><span class="line">    err = os.Chtimes(<span class="string">"test.txt"</span>, lastAccessTime, lastModifyTime)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>硬链接和软链接</li></ul><p>一个普通的文件是一个指向硬盘的inode的地方。<br>硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。</p><p>symbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个硬链接。</span></span><br><span class="line">    <span class="comment">// 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。</span></span><br><span class="line">    <span class="comment">// 删除和重命名不会影响另一个。</span></span><br><span class="line">    err := os.Link(<span class="string">"original.txt"</span>, <span class="string">"original_also.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"creating sym"</span>)</span><br><span class="line">    <span class="comment">// Create a symlink</span></span><br><span class="line">    err = os.Symlink(<span class="string">"original.txt"</span>, <span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。</span></span><br><span class="line">    <span class="comment">// Symlink在Windows中不工作。</span></span><br><span class="line">    fileInfo, err := os.Lstat(<span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Link info: %+v"</span>, fileInfo)</span><br><span class="line">    <span class="comment">//改变软链接的拥有者不会影响原始文件。</span></span><br><span class="line">    err = os.Lchown(<span class="string">"original_sym.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go官方库的文件操作分散在多个包中，比如&lt;code&gt;os&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;包,发现已经有人2015年已经写了一篇这样的文章，写的非常好，我经常在需要使用文件方法的时候回过来查,所以翻译成了中文，记录一下.&lt;br&gt;原文&lt;a href=&quot;https://www.devdungeon.com/content/working-files-go#write_bytes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Working with Files in Go&lt;/a&gt;, 作者&lt;a href=&quot;https://www.devdungeon.com/blogs/nanodano&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; NanoDano&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://github.com/fitzix/categories/Go/"/>
    
    
      <category term="go" scheme="https://github.com/fitzix/tags/go/"/>
    
      <category term="golang" scheme="https://github.com/fitzix/tags/golang/"/>
    
      <category term="filesystem" scheme="https://github.com/fitzix/tags/filesystem/"/>
    
  </entry>
  
  <entry>
    <title>[算法]经典的Top-K问题</title>
    <link href="https://github.com/fitzix/2018/04/16/%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E7%9A%84Top-K%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/fitzix/2018/04/16/算法-经典的Top-K问题/</id>
    <published>2018-04-16T11:57:32.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 Top K 问题？简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数。<br>这个问题也是十分经典的算法问题，不论是面试中还是实际开发中，都非常典型。而这个问题其实也有很多种做法，你真的都懂了么？</p><a id="more"></a><h3 id="立刻就能想到的解法"><a href="#立刻就能想到的解法" class="headerlink" title="立刻就能想到的解法"></a>立刻就能想到的解法</h3><p>既然是要前 K 大的数，那么最直接的当然就是排序了，通过如快排等效率较高的排序算法，可以在平均 O（nlogn）的时间复杂度找到结果。</p><p>这种方式在数据量不大的时候简单可行，但固然不是最优的方法。</p><h3 id="O-n-时间复杂度的方法"><a href="#O-n-时间复杂度的方法" class="headerlink" title="O(n)时间复杂度的方法"></a>O(n)时间复杂度的方法</h3><p>刚刚提到了快排，熟悉算法题的小伙伴应该知道，快排的 partition 划分思想可以用于计算某个位置的数值等问题，例如用来计算中位数；显然，也适用于计算 TopK 问题</p><p><img src="https://ws2.sinaimg.cn/large/b09f1c9dly1g24q5e7ulnj20fo09f3z7.jpg" alt=""></p><p>每次经过划分，如果中间值等于 K ，那么其左边的数就是 Top K 的数据； 当然，如果不等于，只要递归处理左边或者右边的数即可</p><p>该方法的时间复杂度是 O(n) ，简单分析就是第一次划分时遍历数组需要花费 n，而往后每一次都折半（当然不是准确地折半），粗略地计算就是 n + n/2 + n/4 +… &lt; 2n，因此显然时间复杂度是 O(n)</p><p>对比第一个方法显然快了不少，随着数据量的增大，两个方法的时间差距会越来越大</p><p>虽然时间复杂度是 O(n) ，但是缺点也很明显，最主要的就是内存问题，在海量数据的情况下，我们很有可能没办法一次性将数据全部加载入内存，这个时候这个方法就无法完成使命了</p><p>还有一点就是这种思路需要我们修改输入的数组，这也是值得考虑的一点</p><h3 id="利用分布式思想处理海量数据"><a href="#利用分布式思想处理海量数据" class="headerlink" title="利用分布式思想处理海量数据"></a>利用分布式思想处理海量数据</h3><p>面对海量数据，我们就可以放分布式的方向去思考了</p><p>我们可以将数据分散在多台机器中，然后每台机器并行计算各自的 TopK 数据，最后汇总，再计算得到最终的 TopK 数据</p><p>这种数据分片的分布式思想在面试中非常值得一提，在实际项目中也十分常见</p><h3 id="利用最经典的方法，一台机器也能处理海量数据"><a href="#利用最经典的方法，一台机器也能处理海量数据" class="headerlink" title="利用最经典的方法，一台机器也能处理海量数据"></a>利用最经典的方法，一台机器也能处理海量数据</h3><p>其实提到 Top K 问题，最经典的解法还是利用堆。</p><p>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p><p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p><p><img src="https://wx3.sinaimg.cn/large/b09f1c9dly1g24q9cpq6wj20le068mxs.jpg" alt=""><br>将数据插入堆</p><p><img src="https://wx1.sinaimg.cn/large/b09f1c9dly1g24q9ng92dj20lk06a3zb.jpg" alt=""><br>95 大于 20，进行替换</p><p><img src="https://ws1.sinaimg.cn/large/b09f1c9dly1g24q9ywfhhj20lw06et9i.jpg" alt=""></p><p>95 下沉，维持小顶堆</p><p>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p><p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p><p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p><p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">solutionByHeap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (k &gt; input.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : input) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue.peek() &lt; num)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是 Top K 问题？简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数。&lt;br&gt;这个问题也是十分经典的算法问题，不论是面试中还是实际开发中，都非常典型。而这个问题其实也有很多种做法，你真的都懂了么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/fitzix/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见GC算法及Golang GC</title>
    <link href="https://github.com/fitzix/2018/03/20/go-gc/"/>
    <id>https://github.com/fitzix/2018/03/20/go-gc/</id>
    <published>2018-03-20T15:08:02.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言能够支持实时的，高并发的消息系统，在高达百万级别的消息系统中能够将延迟降低到100ms以下，这一切很大一部分需要归功于Go的高效的垃圾回收系统.</p><a id="more"></a><h3 id="GC-算法简介"><a href="#GC-算法简介" class="headerlink" title="GC 算法简介"></a>GC 算法简介</h3><h4 id="GC-自动垃圾回收-的主要问题"><a href="#GC-自动垃圾回收-的主要问题" class="headerlink" title="GC(自动垃圾回收)的主要问题"></a>GC(自动垃圾回收)的主要问题</h4><ul><li>额外的开销(内存/CPU)</li><li>执行GC的时机无法预测，在实时性要求高的场景或事务处理来说可能是不可容忍的</li><li>部分GC算法会Stop-the-world</li></ul><h4 id="GC三种经典的算法："><a href="#GC三种经典的算法：" class="headerlink" title="GC三种经典的算法："></a>GC三种经典的算法：</h4><ul><li>引用计数(reference counting)</li><li>标记-清扫(mark &amp; sweep)</li><li>节点复制(Copying Garbage Collection)</li><li>分代收集(Generational Garbage Collection)</li></ul><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>引用计数的思想非常简单：每个单元维护一个域，保存其它单元指向它的引用数量（类似有向图的入度）。当引用数量为 0 时，将其回收。引用计数是渐进式的，能够将内存管理的开销分布到整个程序之中。C++ 的 share_ptr 使用的就是引用计算方法。<br>引用计数算法实现一般是把所有的单元放在一个单元池里，比如类似 free list。这样所有的单元就被串起来了，就可以进行引用计数了。新分配的单元计数值被设置为 1（注意不是 0，因为申请一般都说 ptr = new object 这种）。每次有一个指针被设为指向该单元时，该单元的计数值加 1；而每次删除某个指向它的指针时，它的计数值减 1。当其引用计数为 0 的时候，该单元会被进行回收。虽然这里说的比较简单，实现的时候还是有很多细节需要考虑，比如删除某个单元的时候，那么它指向的所有单元都需要对引用计数减 1。那么如果这个时候，发现其中某个指向的单元的引用计数又为 0，那么是递归的进行还是采用其他的策略呢？递归处理的话会导致系统颠簸。</p><blockquote><p>优点</p></blockquote><ul><li>GC开销将被均摊到程序运行期，不会有长时间的回收周期</li><li>每个对象的生命周期被明确定义，可用于某些编译器的runtime优化</li><li>算法简单，易于实现</li><li>即时回收，不会等内存状态到达某个阀值再执行回收</li></ul><blockquote><p>缺点</p></blockquote><ul><li>引用计数会频繁更新，带来效率开销</li><li>原生的引用计数算法无法回收循环引用的对象链</li></ul><h5 id="标记-清扫-Mark-and-Sweep"><a href="#标记-清扫-Mark-and-Sweep" class="headerlink" title="标记-清扫(Mark-and-Sweep)"></a>标记-清扫(Mark-and-Sweep)</h5><p>标记-清扫算法为每个对象预留一个Flag位，分为两个阶段，标记阶段会从Root向下递归遍历所有对象，并将所有可达对象的Flag位设为”正在使用”。第二阶段，清扫阶段，遍历所有内存，回收那些所有未被标记为”正在使用”的对象。整个算法的思路很简单，也基本上避免了引用计数法的缺点，但最大的缺点在于回收期间整个系统必须暂停(Stop-the-world)。</p><h5 id="三色标记法-Tri-color-marking"><a href="#三色标记法-Tri-color-marking" class="headerlink" title="三色标记法(Tri-color marking)"></a>三色标记法(Tri-color marking)</h5><p>三色标记算法是对标记阶段的改进，原理如下：</p><ol><li>起初所有对象都是白色。</li><li>从根出发扫描所有可达对象，标记为灰色，放入待处理队列。</li><li>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。</li><li>重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。</li></ol><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>基于追踪的垃圾回收算法（标记-清扫、节点复制）一个主要问题是在生命周期较长的对象上浪费时间（长生命周期的对象是不需要频繁扫描的）。同时，内存分配存在这么一个事实 “most object die young”。基于这两点，分代垃圾回收算法将对象按生命周期长短存放到堆上的两个（或者更多）区域，这些区域就是分代（generation）。对于新生代的区域的垃圾回收频率要明显高于老年代区域.</p><p>分配对象的时候从新生代里面分配，如果后面发现对象的生命周期较长，则将其移到老年代，这个过程叫做 promote。随着不断 promote，最后新生代的大小在整个堆的占用比例不会特别大。收集的时候集中主要精力在新生代就会相对来说效率更高，STW 时间也会更短。</p><h3 id="Golang-GC"><a href="#Golang-GC" class="headerlink" title="Golang GC"></a>Golang GC</h3><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>golang采用三色法作为GC的计算方式, 对于已经扫描过的对象, 如果检测是否由于用户逻辑的变化而引起的数据变化呢, golang中采用了写屏障的方式, 对扫描过后的对象使⽤操作系统写屏障功能⽤来监控⽤户逻辑这段内存。任何时候这段内存发⽣引⽤改变的时候就会造成写屏障发⽣⼀个信号，垃圾回收器会捕获到这样的信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否被改变，这样利⽤状态的重置从⽽实现当对象状态发⽣改变的时候依然可以判断它是活着的还是死的</p><h4 id="go语言垃圾回收总体采用的是经典的mark-and-sweep算法"><a href="#go语言垃圾回收总体采用的是经典的mark-and-sweep算法" class="headerlink" title="go语言垃圾回收总体采用的是经典的mark and sweep算法"></a>go语言垃圾回收总体采用的是经典的mark and sweep算法</h4><ul><li><p>v1.3以前版本 STW（Stop The World)  </p><p>  golang的垃圾回收算法都非常简陋，然后其性能也广被诟病:go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后启动所有任务的执行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的！这个时期国内外很多在生产环境实践go语言的团队都或多或少踩过gc的坑。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景  </p></li><li><p>v1.3 Mark STW, Sweep 并行  </p><p>  1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务了，而是让sweep任务和普通协程任务一样并行的和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。go team自己的说法是减少了50%-70%的暂停时间  </p></li><li><p>v1.5 三色标记法  </p><p>  go 1.5正在实现的垃圾回收器是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。引入了上文介绍的三色标记法，这种方法的mark操作是可以渐进执行的而不需每次都扫描整个内存空间，可以减少stop the world的时间。 由此可以看到，一路走来直到1.5版本，go的垃圾回收性能也是一直在提升，但是相对成熟的垃圾回收系统（如java jvm和javascript v8），go需要优化的路径还很长（但是相信未来一定是美好的~）  </p></li><li><p>v1.8 混合写屏障（hybrid write barrier）  </p><p>  这个版本的 GC 代码相比之前改动还是挺大的，采用一种混合的 write barrier 方式 （Yuasa-style deletion write barrier [Yuasa ‘90] 和 Dijkstra-style insertion write barrier [Dijkstra ‘78]）来避免 堆栈重新扫描。</p><p>  如果检测是否由于用户逻辑的变化而引起的数据变化呢, golang中采用了写屏障的方式, 对扫描过后的对象使⽤操作系统写屏障功能⽤来监控⽤户逻辑这段内存。任何时候这段内存发⽣引⽤改变的时候就会造成写屏障发⽣⼀个信号，垃圾回收器会捕获到这样的信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否被改变，这样利⽤状态的重置从⽽实现当对象状态发⽣改变的时候依然可以判断它是活着的还是死的</p><p>  混合屏障的优势在于它允许堆栈扫描永久地使堆栈变黑（没有STW并且没有写入堆栈的障碍），这完全消除了堆栈重新扫描的需要，从而消除了对堆栈屏障的需求。重新扫描列表。特别是堆栈障碍在整个运行时引入了显着的复杂性，并且干扰了来自外部工具（如GDB和基于内核的分析器）的堆栈遍历。</p><p>  此外，与Dijkstra风格的写屏障一样，混合屏障不需要读屏障，因此指针读取是常规的内存读取; 它确保了进步，因为物体单调地从白色到灰色再到黑色。</p><p>  混合屏障的缺点很小。它可能会导致更多的浮动垃圾，因为它会在标记阶段的任何时刻保留从根（堆栈除外）可到达的所有内容。然而，在实践中，当前的Dijkstra障碍可能几乎保留不变。混合屏障还禁止某些优化：特别是，如果Go编译器可以静态地显示指针是nil，则Go编译器当前省略写屏障，但是在这种情况下混合屏障需要写屏障。这可能会略微增加二进制大小。</p></li></ul><p>通过go team多年对gc的不断改进和忧化，GC的卡顿问题在1.8 版本基本上可以做到 1 毫秒以下的 GC 级别。 实际上，gc低延迟是有代价的，其中最大的是吞吐量的下降。由于需要实现并行处理，线程间同步和多余的数据生成复制都会占用实际逻辑业务代码运行的时间。GHC的全局停止GC对于实现高吞吐量来说是十分合适的，而Go则更擅长与低延迟。 </p><p>并行GC的第二个代价是不可预测的堆空间扩大。程序在GC的运行期间仍能不断分配任意大小的堆空间，因此我们需要在到达最大的堆空间之前实行一次GC，但是过早实行GC会造成不必要的GC扫描，这也是需要衡量利弊的。因此在使用Go时，需要自行保证程序有足够的内存空间</p><h3 id="如何提高GC的性能"><a href="#如何提高GC的性能" class="headerlink" title="如何提高GC的性能"></a>如何提高GC的性能</h3><h4 id="触发GC"><a href="#触发GC" class="headerlink" title="触发GC"></a>触发GC</h4><p>GC触发的时机：2分钟或者内存占用达到一个阈值（当前堆内存占用是上次gc后对内存占用的两倍，当GOGC=100时）</p><h4 id="GC的总时间"><a href="#GC的总时间" class="headerlink" title="GC的总时间"></a>GC的总时间</h4><blockquote><p>Tgc = Tseq + Tmark + Tsweep(T表示time)</p></blockquote><p>Tseq表示是停止用户的goroutine和做一些准备活动（通常很小）需要的时间<br>Tmark是堆标记时间，标记发生在所有用户goroutine停止时，因此可以显著地影响处理的延迟<br>Tsweep是堆清除时间，清除通常与正常的程序运行同时发生，所以对延迟来说是不太关键的</p><p>goroutine被停止后, GC将要开始的是时候会做一些准备工作,如写屏障设置等会执行STW<br>re-scan的时候执行STW,停止用户程序,检验已经扫描的元素是否发生引用的变化</p><p>当前GC的算法是固定的, 用户不能够配置垃圾回收的算法,唯一能够更改就是垃圾回收的阀值, 即GOGC, 用来表示触发GC的条件。当前能够提升垃圾回收效率的唯一方式就是减少垃圾的产生,可通过下面的方式</p><ul><li>内存分配合理</li><li>sync.Pool对象池,重复使用对象, 减少内存分配</li><li>append使用, 提前设置cap的数量, 避免无故扩容</li></ul><h3 id="实践中的一些问题"><a href="#实践中的一些问题" class="headerlink" title="实践中的一些问题"></a>实践中的一些问题</h3><blockquote><p>当停止大量的请求之后, 内存使用量并没有立即停止下来 原因可能如下:</p></blockquote><ul><li>go的垃圾回收有个触发阈值，这个阈值会随着每次内存使用变大而逐渐增大（如初始阈值是10MB则下一次就是20MB，再下一次就成为了40MB…），如果长时间没有触发gc go会主动触发一次（2min）。高峰时内存使用量上去后，除非持续申请内存，靠阈值触发gc已经基本不可能，而是要等最多2min主动gc开始才能触发gc</li><li>go语言在向系统交还内存时只是告诉系统这些内存不需要使用了，可以回收；同时操作系统会采取“拖延症”策略，并不是立即回收，而是等到系统内存紧张时才会开始回收这样该程序又重新申请内存时就可以获得极快的分配速度</li></ul><blockquote><p>gc时间长的问题</p></blockquote><p>尽量避免频繁创建临时堆对象（如&amp;abc{}, new, make等）以减少垃圾收集时的扫描时间，对于需要频繁使用的临时对象考虑直接通过数组缓存进行重用</p><blockquote><p>goroutine泄露的问题</p></blockquote><p>我们的一个服务需要处理很多长连接请求，实现时，对于每个长连接请求各开了一个读取和写入协程，全部采用endless for loop不停地处理收发数据。当连接被远端关闭后，如果不对这两个协程做处理，他们依然会一直运行，并且占用的channel也不会被释放…这里就必须十分注意，在不使用协程后一定要把他依赖的channel close并通过再协程中判断channel是否关闭以保证其退出</p><blockquote><p>少量使用<code>+</code>连接string</p></blockquote><p><code>+</code>来进行string的连接会生成新的对象，降低gc的效率，好的方式是通过append函数来进行。</p><blockquote><p>string与[]byte转化 </p></blockquote><p>在stirng与[]byte之间进行转换，会给gc造成压力 通过gdb，可以先对比下两者的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type = struct []uint8 &#123; uint8 *array; int len; int cap;&#125;</span><br><span class="line">type = struct string &#123; uint8 *str; int len;&#125;</span><br></pre></td></tr></table></figure></p><p>两者发生转换的时候，底层数据结结构会进行复制，因此导致gc效率会变低。<br>解决策略上，一种方式是一直使用<code>[]byte</code>，特别是在数据传输方面，[]byte中也包含着许多string会常用到的有效的操作。<br>另一种是使用更为底层的操作直接进行转化，避免复制行为的发生。主要是使用unsafe.Pointer直接进行转化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go语言能够支持实时的，高并发的消息系统，在高达百万级别的消息系统中能够将延迟降低到100ms以下，这一切很大一部分需要归功于Go的高效的垃圾回收系统.&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://github.com/fitzix/tags/go/"/>
    
      <category term="golang" scheme="https://github.com/fitzix/tags/golang/"/>
    
      <category term="gc" scheme="https://github.com/fitzix/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Golang内存管理</title>
    <link href="https://github.com/fitzix/2017/04/19/Golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://github.com/fitzix/2017/04/19/Golang内存管理/</id>
    <published>2017-04-19T14:30:08.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 的内存管理基于 tcmalloc，可以说起点挺高的。但是 Golang 在实现的时候还做了很多优化，我们下面通过源码来看一下 Golang 的内存管理实现。下面的源码分析基于 go1.8rc3。</p><a id="more"></a><h3 id="tcmalloc-介绍"><a href="#tcmalloc-介绍" class="headerlink" title="tcmalloc 介绍"></a>tcmalloc 介绍</h3><p>关于 tcmalloc 可以参考这篇文章 <a href="http://legendtkl.com/2015/12/11/go-memory/" target="_blank" rel="noopener">tcmalloc</a> 介绍，原始论文可以参考 TCMalloc : Thread-Caching Malloc。</p><h3 id="Golang-内存管理"><a href="#Golang-内存管理" class="headerlink" title="Golang 内存管理"></a>Golang 内存管理</h3><h4 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h4><p>这里先简单介绍一下 Golang 运行调度。在 Golang 里面有三个基本的概念：G, M, P。</p><ul><li>G: Goroutine 执行的上下文环境</li><li>M: 操作系统线程</li><li>P: Processer。进程调度的关键，调度器，也可以认为约等于 CPU</li></ul><p>一个 Goroutine 的运行需要 G + P + M 三部分结合起来。好，先简单介绍到这里，更详细的放在后面的文章里面来说</p><h4 id="逃逸分析（escape-analysis）"><a href="#逃逸分析（escape-analysis）" class="headerlink" title="逃逸分析（escape analysis）"></a>逃逸分析（escape analysis）</h4><p>对于手动管理内存的语言，比如 C/C++，我们使用 malloc 或者 new 申请的变量会被分配到堆上。但是 Golang 并不是这样，虽然 Golang 语言里面也有 new。Golang 编译器决定变量应该分配到什么地方时会进行逃逸分析。下面是一个简单的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> *x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>将上面文件保存为 escape.go，执行下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run -gcflags &apos;-m -l&apos; escape.go</span><br><span class="line">./escape.go:6: moved to heap: x</span><br><span class="line">./escape.go:7: &amp;x escape to heap</span><br><span class="line">./escape.go:11: bar new(int) does not escape</span><br></pre></td></tr></table></figure><p>上面的意思是 foo() 中的 x 最后在堆上分配，而 bar() 中的 x 最后分配在了栈上。在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：</p><p>How do I know whether a variable is allocated on the heap or the stack?</p><blockquote><p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p><p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p><p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p></blockquote><p>简单翻译一下:</p><p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p><blockquote><p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p><p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p><p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。</p></blockquote><h4 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><p>几个关键的地方：</p><ul><li>mcache: per-P cache，可以认为是 local cache</li><li>mcentral: 全局 cache，mcache 不够用的时候向 mcentral 申请</li><li>mheap: 当 mcentral 也不够用的时候，通过 mheap 向操作系统申请</li></ul><p>可以将其看成多级内存分配器。</p><h5 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h5><p>我们知道每个 Gorontine 的运行都是绑定到一个 P 上面，mcache 是每个 P 的 cache。这么做的好处是分配内存时不需要加锁。mcache 结构如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-thread (in Go, per-P) cache for small objects.</span></span><br><span class="line"><span class="comment">// No locking needed because it is per-thread (per-P).</span></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The following members are accessed on every malloc,</span></span><br><span class="line">    <span class="comment">// so they are grouped here for better caching.</span></span><br><span class="line">    next_sample <span class="keyword">int32</span>   <span class="comment">// trigger heap sample after allocating this many bytes</span></span><br><span class="line">    local_scan  <span class="keyword">uintptr</span> <span class="comment">// bytes of scannable heap allocated</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小对象分配器，小于 16 byte 的小对象都会通过 tiny 来分配。</span></span><br><span class="line">    tiny             <span class="keyword">uintptr</span></span><br><span class="line">    tinyoffset       <span class="keyword">uintptr</span></span><br><span class="line">    local_tinyallocs <span class="keyword">uintptr</span> <span class="comment">// number of tiny allocs not counted in other stats</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The rest is not accessed on every malloc.</span></span><br><span class="line">    alloc [_NumSizeClasses]*mspan <span class="comment">// spans to allocate from</span></span><br><span class="line"></span><br><span class="line">    stackcache [_NumStackOrders]stackfreelist</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local allocator stats, flushed during GC.</span></span><br><span class="line">    local_nlookup    <span class="keyword">uintptr</span>                  <span class="comment">// number of pointer lookups</span></span><br><span class="line">    local_largefree  <span class="keyword">uintptr</span>                  <span class="comment">// bytes freed for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    local_nlargefree <span class="keyword">uintptr</span>                  <span class="comment">// number of frees for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    local_nsmallfree [_NumSizeClasses]<span class="keyword">uintptr</span> <span class="comment">// number of frees for small objects (&lt;=maxsmallsize)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以暂时只关注 alloc [_NumSizeClasses]*mspan，这是一个大小为 67 的指针（指针指向 mspan ）数组（_NumSizeClasses = 67），每个数组元素用来包含特定大小的块。当要分配内存大小时，为 object 在 alloc 数组中选择合适的元素来分配。67 种块大小为 0，8 byte, 16 byte, … ，这个和 tcmalloc 稍有区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: sizeclasses.go</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure><p>这里仔细想有个小问题，上面的 alloc 类似内存池的 freelist 数组或者链表，正常实现每个数组元素是一个链表，链表由特定大小的块串起来。但是这里统一使用了 mspan 结构，那么只有一种可能，就是 mspan 中记录了需要分配的块大小。我们来看一下 mspan 的结构。</p><h5 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h5><p>span 在 tcmalloc 中作为一种管理内存的基本单位而存在。Golang 的 mspan 的结构如下，省略了部分内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan     <span class="comment">// next span in list, or nil if none</span></span><br><span class="line">    prev *mspan     <span class="comment">// previous span in list, or nil if none</span></span><br><span class="line">    list *mSpanList <span class="comment">// For debugging. <span class="doctag">TODO:</span> Remove.</span></span><br><span class="line"></span><br><span class="line">    startAddr     <span class="keyword">uintptr</span>   <span class="comment">// address of first byte of span aka s.base()</span></span><br><span class="line">    npages        <span class="keyword">uintptr</span>   <span class="comment">// number of pages in span</span></span><br><span class="line">    stackfreelist gclinkptr <span class="comment">// list of free stacks, avoids overloading freelist</span></span><br><span class="line">    <span class="comment">// freeindex is the slot index between 0 and nelems at which to begin scanning</span></span><br><span class="line">    <span class="comment">// for the next free object in this span.</span></span><br><span class="line">    freeindex <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Look up nelems from sizeclass and remove this field if it</span></span><br><span class="line">    <span class="comment">// helps performance.</span></span><br><span class="line">    nelems <span class="keyword">uintptr</span> <span class="comment">// number of object in the span.</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 用位图来管理可用的 free object，1 表示可用</span></span><br><span class="line">    allocCache <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    sizeclass   <span class="keyword">uint8</span>      <span class="comment">// size class</span></span><br><span class="line">    ...</span><br><span class="line">    elemsize    <span class="keyword">uintptr</span>    <span class="comment">// computed from sizeclass or from npages</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的结构可以看出：</p><ul><li>next, prev: 指针域，因为 mspan 一般都是以链表形式使用</li><li>npages: mspan 的大小为 page 大小的整数倍</li><li>sizeclass: 0 ~ _NumSizeClasses 之间的一个值，这个解释了我们的疑问。比如，sizeclass = 3，那么这个 mspan 被分割成 32 byte 的块</li><li>elemsize: 通过 sizeclass 或者 npages 可以计算出来。比如 sizeclass = 3, elemsize = 32 byte。对于大于 32Kb 的内存分配，都是分配整数页，elemsize = page_size * npages</li><li>nelems: span 中包块的总数目</li><li>freeindex: 0 ~ nelemes-1，表示分配到第几个块</li></ul><h6 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h6><p>上面说到当 mcache 不够用的时候，会从 mcentral 申请。那我们下面就来介绍一下 mcentral。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex</span><br><span class="line">    sizeclass <span class="keyword">int32</span></span><br><span class="line">    nonempty  mSpanList <span class="comment">// list of spans with a free object, ie a nonempty free list</span></span><br><span class="line">    empty     mSpanList <span class="comment">// list of spans with no free objects (or cached in an mcache)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mSpanList <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *mspan</span><br><span class="line">    last  *mspan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mcentral 分析：</p><ul><li>sizeclass: 也有成员 sizeclass，那么 mcentral 是不是也有 67 个呢？是的</li><li>lock: 因为会有多个 P 过来竞争</li><li>nonempty: mspan 的双向链表，当前 mcentral 中可用的 mspan list</li><li>empty: 已经被使用的，可以认为是一种对所有 mspan 的 track</li></ul><p>问题来了，mcentral 存在于什么地方？虽然在上面我们将 mcentral 和 mheap 作为两个部分来讲，但是作为全局的结构，这两部分是可以定义在一起的。实际上也是这样，mcentral 包含在 mheap 中。</p><h5 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex</span><br><span class="line">    free      [_MaxMHeapList]mSpanList <span class="comment">// free lists of given length</span></span><br><span class="line">    freelarge mSpanList                <span class="comment">// free lists length &gt;= _MaxMHeapList</span></span><br><span class="line">    busy      [_MaxMHeapList]mSpanList <span class="comment">// busy lists of large objects of given length</span></span><br><span class="line">    busylarge mSpanList                <span class="comment">// busy lists of large objects length &gt;= _MaxMHeapList</span></span><br><span class="line">    sweepgen  <span class="keyword">uint32</span>                   <span class="comment">// sweep generation, see comment in mspan</span></span><br><span class="line">    sweepdone <span class="keyword">uint32</span>                   <span class="comment">// all spans are swept</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allspans is a slice of all mspans ever created. Each mspan</span></span><br><span class="line">    <span class="comment">// appears exactly once.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The memory for allspans is manually managed and can be</span></span><br><span class="line">    <span class="comment">// reallocated and move as the heap grows.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// In general, allspans is protected by mheap_.lock, which</span></span><br><span class="line">    <span class="comment">// prevents concurrent access as well as freeing the backing</span></span><br><span class="line">    <span class="comment">// store. Accesses during STW might not hold the lock, but</span></span><br><span class="line">    <span class="comment">// must ensure that allocation cannot happen around the</span></span><br><span class="line">    <span class="comment">// access (since that may free the backing store).</span></span><br><span class="line">    allspans []*mspan <span class="comment">// all spans out there</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// spans is a lookup table to map virtual address page IDs to *mspan.</span></span><br><span class="line">    <span class="comment">// For allocated spans, their pages map to the span itself.</span></span><br><span class="line">    <span class="comment">// For free spans, only the lowest and highest pages map to the span itself.</span></span><br><span class="line">    <span class="comment">// Internal pages map to an arbitrary span.</span></span><br><span class="line">    <span class="comment">// For pages that have never been allocated, spans entries are nil.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is backed by a reserved region of the address space so</span></span><br><span class="line">    <span class="comment">// it can grow without moving. The memory up to len(spans) is</span></span><br><span class="line">    <span class="comment">// mapped. cap(spans) indicates the total reserved memory.</span></span><br><span class="line">    spans []*mspan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweepSpans contains two mspan stacks: one of swept in-use</span></span><br><span class="line">    <span class="comment">// spans, and one of unswept in-use spans. These two trade</span></span><br><span class="line">    <span class="comment">// roles on each GC cycle. Since the sweepgen increases by 2</span></span><br><span class="line">    <span class="comment">// on each cycle, this means the swept spans are in</span></span><br><span class="line">    <span class="comment">// sweepSpans[sweepgen/2%2] and the unswept spans are in</span></span><br><span class="line">    <span class="comment">// sweepSpans[1-sweepgen/2%2]. Sweeping pops spans from the</span></span><br><span class="line">    <span class="comment">// unswept stack and pushes spans that are still in-use on the</span></span><br><span class="line">    <span class="comment">// swept stack. Likewise, allocating an in-use span pushes it</span></span><br><span class="line">    <span class="comment">// on the swept stack.</span></span><br><span class="line">    sweepSpans [<span class="number">2</span>]gcSweepBuf</span><br><span class="line"></span><br><span class="line">    _ <span class="keyword">uint32</span> <span class="comment">// align uint64 fields on 32-bit for atomics</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proportional sweep</span></span><br><span class="line">    pagesInUse        <span class="keyword">uint64</span>  <span class="comment">// pages of spans in stats _MSpanInUse; R/W with mheap.lock</span></span><br><span class="line">    spanBytesAlloc    <span class="keyword">uint64</span>  <span class="comment">// bytes of spans allocated this cycle; updated atomically</span></span><br><span class="line">    pagesSwept        <span class="keyword">uint64</span>  <span class="comment">// pages swept this cycle; updated atomically</span></span><br><span class="line">    sweepPagesPerByte <span class="keyword">float64</span> <span class="comment">// proportional sweep ratio; written with lock, read without</span></span><br><span class="line">    <span class="comment">// TODO(austin): pagesInUse should be a uintptr, but the 386</span></span><br><span class="line">    <span class="comment">// compiler can't 8-byte align fields.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Malloc stats.</span></span><br><span class="line">    largefree  <span class="keyword">uint64</span>                  <span class="comment">// bytes freed for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    nlargefree <span class="keyword">uint64</span>                  <span class="comment">// number of frees for large objects (&gt;maxsmallsize)</span></span><br><span class="line">    nsmallfree [_NumSizeClasses]<span class="keyword">uint64</span> <span class="comment">// number of frees for small objects (&lt;=maxsmallsize)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// range of addresses we might see in the heap</span></span><br><span class="line">    bitmap         <span class="keyword">uintptr</span> <span class="comment">// Points to one byte past the end of the bitmap</span></span><br><span class="line">    bitmap_mapped  <span class="keyword">uintptr</span></span><br><span class="line">    arena_start    <span class="keyword">uintptr</span></span><br><span class="line">    arena_used     <span class="keyword">uintptr</span> <span class="comment">// always mHeap_Map&#123;Bits,Spans&#125; before updating</span></span><br><span class="line">    arena_end      <span class="keyword">uintptr</span></span><br><span class="line">    arena_reserved <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// central free lists for small size classes.</span></span><br><span class="line">    <span class="comment">// the padding makes sure that the MCentrals are</span></span><br><span class="line">    <span class="comment">// spaced CacheLineSize bytes apart, so that each MCentral.lock</span></span><br><span class="line">    <span class="comment">// gets its own cache line.</span></span><br><span class="line">    central [_NumSizeClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spanalloc             fixalloc <span class="comment">// allocator for span*</span></span><br><span class="line">    cachealloc            fixalloc <span class="comment">// allocator for mcache*</span></span><br><span class="line">    specialfinalizeralloc fixalloc <span class="comment">// allocator for specialfinalizer*</span></span><br><span class="line">    specialprofilealloc   fixalloc <span class="comment">// allocator for specialprofile*</span></span><br><span class="line">    speciallock           mutex    <span class="comment">// lock for special record allocators.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mheap_ mheap</span><br></pre></td></tr></table></figure><p>mheap_ 是一个全局变量，会在系统初始化的时候初始化（在函数 mallocinit() 中）。我们先看一下 mheap 具体结构。</p><ul><li>allspans []*mspan: 所有的 spans 都是通过 mheap_ 申请，所有申请过的 mspan 都会记录在 allspans。结构体中的 lock 就是用来保证并发安全的。注释中有关于 STW 的说明，这个之后会在 Golang 的 GC 文章中细说。</li><li>central [_NumSizeClasses]…: 这个就是之前介绍的 mcentral ，每种大小的块对应一个 mcentral。mcentral 上面介绍过了。pad 可以认为是一个字节填充，为了避免伪共享（false sharing）问题的。</li><li>sweepgen, sweepdone: GC 相关。（Golang 的 GC 策略是 Mark &amp; Sweep, 这里是用来表示 sweep 的，这里就不再深入了。</li><li>free [_MaxMHeapList]mSpanList: 这是一个 SpanList 数组，每个 SpanList 里面的 mspan 由 1 ~ 127 (_MaxMHeapList - 1) 个 page 组成。比如 free[3] 是由包含 3 个 page 的 mspan 组成的链表。free 表示的是 free list，也就是未分配的。对应的还有 busy list。</li><li>freelarge mSpanList: mspan 组成的链表，每个元素（也就是 mspan）的 page 个数大于 127。对应的还有 busylarge。</li><li>spans []*mspan: 记录 arena 区域页号（page number）和 mspan 的映射关系。</li><li><p>arena_start, arena_end, arena_used: 要解释这几个变量之前要解释一下 arena。arena 是 Golang 中用于分配内存的连续虚拟地址区域。由 mheap 管理，堆上申请的所有内存都来自 arena。那么如何标志内存可用呢？操作系统的常见做法用两种：一种是用链表将所有的可用内存都串起来；另一种是使用位图来标志内存块是否可用。结合上面一条 spans，内存的布局是下面这样的。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+---------------------+-----------------------+</span><br><span class="line">|    spans              |    bitmap           |   arena               |</span><br><span class="line">+-----------------------+---------------------+-----------------------+</span><br></pre></td></tr></table></figure></li><li><p>spanalloc, cachealloc fixalloc: fixalloc 是 free-list，用来分配特定大小的块。</p></li><li>剩下的是一些统计信息和 GC 相关的信息，这里暂且按住不表，以后专门拿出来说。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在系统初始化阶段，上面介绍的几个结构会被进行初始化，我们直接看一下初始化代码：mallocinit()。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//一些系统检测代码，略去</span></span><br><span class="line">    <span class="keyword">var</span> p, bitmapSize, spansSize, pSize, limit <span class="keyword">uintptr</span></span><br><span class="line">    <span class="keyword">var</span> reserved <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit = runtime.memlimit();</span></span><br><span class="line">    <span class="comment">// See https://golang.org/issue/5049</span></span><br><span class="line">    <span class="comment">// TODO(rsc): Fix after 1.1.</span></span><br><span class="line">    limit = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//系统指针大小 PtrSize = 8，表示这是一个 64 位系统。</span></span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; (limit == <span class="number">0</span> || limit &gt; <span class="number">1</span>&lt;&lt;<span class="number">30</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的 arenaSize, bitmapSize, spansSize 分别对应 mheap 那一小节里面提到 arena 区大小，bitmap 区大小，spans 区大小。</span></span><br><span class="line">        arenaSize := round(_MaxMem, _PageSize)</span><br><span class="line">        bitmapSize = arenaSize / (sys.PtrSize * <span class="number">8</span> / <span class="number">2</span>)</span><br><span class="line">        spansSize = arenaSize / _PageSize * sys.PtrSize</span><br><span class="line">        spansSize = round(spansSize, _PageSize)</span><br><span class="line">        <span class="comment">//尝试从不同地址开始申请</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">0x7f</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">                p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span>:</span><br><span class="line">                p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            pSize = bitmapSize + spansSize + arenaSize + _PageSize</span><br><span class="line">            <span class="comment">//向 OS 申请大小为 pSize 的连续的虚拟地址空间</span></span><br><span class="line">            p = <span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))</span><br><span class="line">            <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是 32 位系统代码对应的操作，略去。</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    p1 := round(p, _PageSize)</span><br><span class="line"></span><br><span class="line">    spansStart := p1</span><br><span class="line">    mheap_.bitmap = p1 + spansSize + bitmapSize</span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// Set arena_start such that we can accept memory</span></span><br><span class="line">        <span class="comment">// reservations located anywhere in the 4GB virtual space.</span></span><br><span class="line">        mheap_.arena_start = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mheap_.arena_start = p1 + (spansSize + bitmapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    mheap_.arena_end = p + pSize</span><br><span class="line">    mheap_.arena_used = p1 + (spansSize + bitmapSize)</span><br><span class="line">    mheap_.arena_reserved = reserved</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mheap_.arena_start&amp;(_PageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"bad pagesize"</span>, hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), <span class="string">"start"</span>, hex(mheap_.arena_start))</span><br><span class="line">        throw(<span class="string">"misrounded allocation in mallocinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the rest of the allocator.</span></span><br><span class="line">    mheap_.init(spansStart, spansSize)</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.mcache = allocmcache()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面对代码做了简单的注释，下面详细解说其中的部分功能函数。</p><h4 id="arena-相关"><a href="#arena-相关" class="headerlink" title="arena 相关"></a>arena 相关</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arenaSize := round(_MaxMem, _PageSize)</span><br><span class="line">bitmapSize = arenaSize / (sys.PtrSize * <span class="number">8</span> / <span class="number">2</span>)</span><br><span class="line">spansSize = arenaSize / _PageSize * sys.PtrSize</span><br><span class="line">spansSize = round(spansSize, _PageSize)</span><br><span class="line"></span><br><span class="line">_MaxMem = <span class="keyword">uintptr</span>(<span class="number">1</span>&lt;&lt;_MHeapMap_TotalBits - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>首先解释一下变量 _MaxMem ，里面还有一个变量就不再列出来了。简单来说 _MaxMem 就是系统为 arena 区分配的大小：64 位系统分配 512 G；对于 Windows 64 位系统，arena 区分配 32 G。round 是一个对齐操作，向上取 _PageSize 的倍数。实现也很有意思，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// round n up to a multiple of a.  a must be a power of 2.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">round</span><span class="params">(n, a <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bitmap 用两个 bit 表示一个字的可用状态，那么算下来 bitmap 的大小为 16 G。读过 Golang 源码的同学会发现其实这段代码的注释里写的 bitmap 的大小为 32 G。其实是这段注释很久没有更新了，之前是用 4 个 bit 来表示一个字的可用状态，这真是一个悲伤的故事啊。</p><p>spans 记录的 arena 区的块页号和对应的 mspan 指针的对应关系。比如 arena 区内存地址 x，对应的页号就是 page_num = (x - arena_start) / page_size，那么 spans 就会记录 spans[page_num] = x。如果 arena 为 512 G的话，spans 区的大小为 512 G / 8K * 8 = 512 M。这里值得注意的是 Golang 的内存管理虚拟地址页大小为 8k。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageSize = <span class="number">1</span> &lt;&lt; _PageShift</span><br><span class="line"></span><br><span class="line">_PageShift = <span class="number">13</span></span><br></pre></td></tr></table></figure><p>所以这一段连续的的虚拟内存布局（64 位）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+---------------------+-----------------------+</span><br><span class="line">|    spans 512M         |    bitmap 16G       |   arena 512           |</span><br><span class="line">+-----------------------+---------------------+-----------------------+</span><br></pre></td></tr></table></figure><h4 id="虚拟地址申请"><a href="#虚拟地址申请" class="headerlink" title="虚拟地址申请"></a>虚拟地址申请</h4><p>主要是下面这段代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试从不同地址开始申请</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">0x7f</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">        p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span>:</span><br><span class="line">        p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pSize = bitmapSize + spansSize + arenaSize + _PageSize</span><br><span class="line">    <span class="comment">//向 OS 申请大小为 pSize 的连续的虚拟地址空间</span></span><br><span class="line">    p = <span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))</span><br><span class="line">    <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的时候，Golang 向操作系统申请一段连续的地址空间，就是上面的 spans + bitmap + arena。p 就是这段连续地址空间的开始地址，不同平台的 p 取值不一样。像 OS 申请的时候视不同的 OS 版本，调用不同的系统调用，比如 Unix 系统调用 mmap (mmap 想操作系统内核申请新的虚拟地址区间，可指定起始地址和长度)，Windows 系统调用 VirtualAlloc （类似 mmap）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsd</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; <span class="keyword">uint64</span>(n) &gt; <span class="number">1</span>&lt;&lt;<span class="number">32</span> || sys.GoosNacl != <span class="number">0</span> &#123;</span><br><span class="line">        *reserved = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(p) &lt; <span class="number">4096</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//darwin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(p) &lt; <span class="number">4096</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//linux</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(p) &lt; <span class="number">4096</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//windows</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, reserved *<span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    *reserved = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// v is just a hint.</span></span><br><span class="line">    <span class="comment">// First try at v.</span></span><br><span class="line">    v = unsafe.Pointer(stdcall4(_VirtualAlloc, <span class="keyword">uintptr</span>(v), n, _MEM_RESERVE, _PAGE_READWRITE))</span><br><span class="line">    <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next let the kernel choose the address.</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(stdcall4(_VirtualAlloc, <span class="number">0</span>, n, _MEM_RESERVE, _PAGE_READWRITE))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mheap-初始化"><a href="#mheap-初始化" class="headerlink" title="mheap 初始化"></a>mheap 初始化</h4><p>我们上面介绍 mheap 结构的时候知道 spans, bitmap, arena 都是存在于 mheap 中的，从操作系统申请完地址之后就是初始化 mheap 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    p1 := round(p, _PageSize)</span><br><span class="line"></span><br><span class="line">    spansStart := p1</span><br><span class="line">    mheap_.bitmap = p1 + spansSize + bitmapSize</span><br><span class="line">    <span class="keyword">if</span> sys.PtrSize == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// Set arena_start such that we can accept memory</span></span><br><span class="line">        <span class="comment">// reservations located anywhere in the 4GB virtual space.</span></span><br><span class="line">        mheap_.arena_start = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mheap_.arena_start = p1 + (spansSize + bitmapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    mheap_.arena_end = p + pSize</span><br><span class="line">    mheap_.arena_used = p1 + (spansSize + bitmapSize)</span><br><span class="line">    mheap_.arena_reserved = reserved</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mheap_.arena_start&amp;(_PageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"bad pagesize"</span>, hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), <span class="string">"start"</span>, hex(mheap_.arena_start))</span><br><span class="line">        throw(<span class="string">"misrounded allocation in mallocinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the rest of the allocator.</span></span><br><span class="line">    mheap_.init(spansStart, spansSize)</span><br><span class="line">    <span class="comment">//获取当前 G</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="comment">// 获取 G 上绑定的 M 的 mcache</span></span><br><span class="line">    _g_.m.mcache = allocmcache()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p 是从连续虚拟地址的起始地址，先进行对齐，然后初始化 arena，bitmap，spans 地址。mheap_.init()会初始化 fixalloc 等相关的成员，还有 mcentral 的初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">init</span><span class="params">(spansStart, spansBytes <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">    h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">    h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">    h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// h-&gt;mapcache needs no init</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.free &#123;</span><br><span class="line">        h.free[i].init()</span><br><span class="line">        h.busy[i].init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.freelarge.init()</span><br><span class="line">    h.busylarge.init()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">        h.central[i].mcentral.init(<span class="keyword">int32</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp := (*slice)(unsafe.Pointer(&amp;h.spans))</span><br><span class="line">    sp.array = unsafe.Pointer(spansStart)</span><br><span class="line">    sp.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">    sp.<span class="built_in">cap</span> = <span class="keyword">int</span>(spansBytes / sys.PtrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mheap 初始化之后，对当前的线程也就是 M 进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取当前 G</span><br><span class="line">_g_ := getg()</span><br><span class="line">// 获取 G 上绑定的 M 的 mcache</span><br><span class="line">_g_.m.mcache = allocmcache()</span><br></pre></td></tr></table></figure><h4 id="per-P-mcache-初始化"><a href="#per-P-mcache-初始化" class="headerlink" title="per-P mcache 初始化"></a>per-P mcache 初始化</h4><p>上面好像并没有说到针对 P 的 mcache 初始化，因为这个时候还没有初始化 P。我们看一下 bootstrap 的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mallocinit()</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> procs &gt; _MaxGomaxprocs &#123;</span><br><span class="line">        procs = _MaxGomaxprocs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mallocinit() 上面说过了。对 P 的初始化在函数 procresize() 中执行，我们下面只看内存相关的部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// initialize new P's</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            pp = <span class="built_in">new</span>(p)</span><br><span class="line">            pp.id = i</span><br><span class="line">            pp.status = _Pgcstop</span><br><span class="line">            pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">                pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// P mcache 初始化</span></span><br><span class="line">        <span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">                    throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// P[0] 分配给主 Goroutine</span></span><br><span class="line">                pp.mcache = getg().m.mcache <span class="comment">// bootstrap</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// P[0] 之外的 P 申请 mcache</span></span><br><span class="line">                pp.mcache = allocmcache()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 P 都存放在一个全局数组 allp 中，procresize() 的目的就是将 allp 中用到的 P 进行初始化，同时对多余 P 的资源剥离。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>先说一下给对象 object 分配内存的主要流程：</p><ul><li>ject size &gt; 32K，则使用 mheap 直接分配</li><li>object size &lt; 16 byte，使用 mcache 的小对象分配器 tiny 直接分配。 （其实 tiny 就是一个指针，暂且这么说吧</li><li>object size &gt; 16 byte &amp;&amp; size &lt;=32K byte 时，先使用 mcache 中对应的 size class 分配</li><li>如果 mcache 对应的 size class 的 span 已经没有可用的块，则向 mcentral 请求</li><li>如果 mcentral 也没有可用的块，则向 mheap 申请，并切分</li><li>如果 mheap 也没有合适的 span，则想操作系统申请</li></ul><p>我们看一下在堆上，也就是 arena 区分配内存的相关函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := foo()</span><br><span class="line">    <span class="built_in">println</span>(*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据之前介绍的逃逸分析，foo() 中的 x 会被分配到堆上。把上面代码保存为 test1.go 看一下汇编代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &apos;-l&apos; -o test1 test1.go</span><br><span class="line">$ go tool objdump -s &quot;main\.foo&quot; test1</span><br><span class="line">TEXT main.foo(SB) /Users/didi/code/go/malloc_example/test2.go</span><br><span class="line">    test2.go:3  0x2040  65488b0c25a0080000  GS MOVQ GS:0x8a0, CX</span><br><span class="line">    test2.go:3  0x2049  483b6110        CMPQ 0x10(CX), SP</span><br><span class="line">    test2.go:3  0x204d  762a            JBE 0x2079</span><br><span class="line">    test2.go:3  0x204f  4883ec10        SUBQ $0x10, SP</span><br><span class="line">    test2.go:4  0x2053  488d1d66460500      LEAQ 0x54666(IP), BX</span><br><span class="line">    test2.go:4  0x205a  48891c24        MOVQ BX, 0(SP)</span><br><span class="line">    test2.go:4  0x205e  e82d8f0000      CALL runtime.newobject(SB)</span><br><span class="line">    test2.go:4  0x2063  488b442408      MOVQ 0x8(SP), AX</span><br><span class="line">    test2.go:4  0x2068  48c70001000000      MOVQ $0x1, 0(AX)</span><br><span class="line">    test2.go:5  0x206f  4889442418      MOVQ AX, 0x18(SP)</span><br><span class="line">    test2.go:5  0x2074  4883c410        ADDQ $0x10, SP</span><br><span class="line">    test2.go:5  0x2078  c3          RET</span><br><span class="line">    test2.go:3  0x2079  e8a28d0400      CALL runtime.morestack_noctxt(SB)</span><br><span class="line">    test2.go:3  0x207e  ebc0            JMP main.foo(SB)</span><br></pre></td></tr></table></figure><p>堆上内存分配调用了 runtime 包的 newobject 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    c := gomcache()</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.kind&amp;kindNoPointers != <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">        <span class="comment">// object size &lt;= 32K</span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">            <span class="comment">// 小于 16 byte 的小对象分配</span></span><br><span class="line">            off := c.tinyoffset</span><br><span class="line">            <span class="comment">// Align tiny pointer for required (conservative) alignment.</span></span><br><span class="line">            <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">8</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">4</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.local_tinyallocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line">            span := c.alloc[tinySizeClass]</span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, _, shouldhelpgc = c.nextFree(tinySizeClass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">            <span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">            <span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">                c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">                c.tinyoffset = size</span><br><span class="line">            &#125;</span><br><span class="line">            size = maxTinySize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// object size &gt;= 16 byte  &amp;&amp; object size &lt;= 32K byte</span></span><br><span class="line">            <span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">            <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">                sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">            &#125;</span><br><span class="line">            size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">            span := c.alloc[sizeclass]</span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(sizeclass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//object size &gt; 32K byte</span></span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            s = largeAlloc(size, needzero)</span><br><span class="line">        &#125;)</span><br><span class="line">        s.freeindex = <span class="number">1</span></span><br><span class="line">        s.allocCount = <span class="number">1</span></span><br><span class="line">        x = unsafe.Pointer(s.base())</span><br><span class="line">        size = s.elemsize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个分配过程可以根据 object size 拆解成三部分：size &lt; 16 byte, 16 byte &lt;= size &lt;= 32 K byte, size &gt; 32 K byte。</p><h5 id="size-小于-16-byte"><a href="#size-小于-16-byte" class="headerlink" title="size 小于 16 byte"></a>size 小于 16 byte</h5><p>对于小于 16 byte 的内存块，mcache 有个专门的内存区域 tiny 用来分配，tiny 是指针，指向开始地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">            off := c.tinyoffset</span><br><span class="line">            <span class="comment">// 地址对齐</span></span><br><span class="line">            <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">8</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">4</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                off = round(off, <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分配</span></span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.local_tinyallocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tiny 不够了，为其重新分配一个 16 byte 内存块</span></span><br><span class="line">            span := c.alloc[tinySizeClass]</span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, _, shouldhelpgc = c.nextFree(tinySizeClass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            <span class="comment">//将申请的内存块全置为 0</span></span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            (*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">            <span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">            <span class="comment">// 如果申请的内存块用不完，则将剩下的给 tiny，用 tinyoffset 记录分配了多少。</span></span><br><span class="line">            <span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">                c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">                c.tinyoffset = size</span><br><span class="line">            &#125;</span><br><span class="line">            size = maxTinySize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，tinyoffset 表示 tiny 当前分配到什么地址了，之后的分配根据 tinyoffset 寻址。先根据要分配的对象大小进行地址对齐，比如 size 是 8 的倍数，tinyoffset 和 8 对齐。然后就是进行分配。如果 tiny 剩余的空间不够用，则重新申请一个 16 byte 的内存块，并分配给 object。如果有结余，则记录在 tiny 上。</p><h5 id="size-大于-32-K-byte"><a href="#size-大于-32-K-byte" class="headerlink" title="size 大于 32 K byte"></a>size 大于 32 K byte</h5><p>对于大于 32 Kb 的内存分配，直接跳过 mcache 和 mcentral，通过 mheap 分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            s = largeAlloc(size, needzero)</span><br><span class="line">        &#125;)</span><br><span class="line">        s.freeindex = <span class="number">1</span></span><br><span class="line">        s.allocCount = <span class="number">1</span></span><br><span class="line">        x = unsafe.Pointer(s.base())</span><br><span class="line">        size = s.elemsize</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeAlloc</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    npages := size &gt;&gt; _PageShift</span><br><span class="line">    <span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">        npages++</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    s := mheap_.alloc(npages, <span class="number">0</span>, <span class="literal">true</span>, needzero)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">"out of memory"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s.limit = s.base() + size</span><br><span class="line">    heapBitsForSpan(s.base()).initSpan(s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大于 32 K 的内存分配都是分配整数页，先右移然后低位与计算需要的页数。</p><h5 id="size-介于-16-和-32K"><a href="#size-介于-16-和-32K" class="headerlink" title="size 介于 16 和 32K"></a>size 介于 16 和 32K</h5><p>对于 size 介于 16 ~ 32K byte 的内存分配先计算应该分配的 sizeclass，然后去 mcache 里面 alloc[sizeclass] 申请，如果 mcache.alloc[sizeclass] 不足以申请，则 mcache 向 mcentral 申请，然后再分配。mcentral 给 mcache 分配完之后会判断自己需不需要扩充，如果需要则想 mheap 申请。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//计算 sizeclass</span></span><br><span class="line">            <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">                sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-       <span class="number">1</span>)/largeSizeDiv]</span><br><span class="line">            &#125;</span><br><span class="line">            size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">            span := c.alloc[sizeclass]</span><br><span class="line">            <span class="comment">//从对应的 span 里面分配一个 object </span></span><br><span class="line">            v := nextFreeFast(span)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(sizeclass)</span><br><span class="line">            &#125;</span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">            <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先看一下如何计算 sizeclass 的，预先定义了两个数组：size_to_class8 和 size_to_class128。 数组 size_to_class8，其第 i 个值表示地址区间 ( (i-1)<em>8, i</em>8 ] (smallSizeDiv = 8) 对应的 sizeclass，size_to_class128 类似。小于 1024 - 8 = 1016 （smallSizeMax=1024），使用 size_to_class8，否则使用数组 size_to_class128。看一下数组具体的值：0, 1, 2, 3, 3, 4, 4…。举个例子，比如要分配 17 byte 的内存 （16 byte 以下的使用 mcache.tiny 分配），sizeclass = size_to_calss8[(17+7)/8] = size_to_class8[3] = 3。不得不说这种用空间换时间的策略确实提高了运行效率。</p><p>计算出 sizeclass，那么就可以去 mcache.alloc[sizeclass] 分配了，注意这是一个 mspan 指针，真正的分配函数是 nextFreeFast() 函数。如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFreeFast returns the next free object if one is quickly available.</span></span><br><span class="line"><span class="comment">// Otherwise it returns 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">    theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line">    <span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">        result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line">        <span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">            freeidx := result + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            s.allocCache &gt;&gt;= (theBit + <span class="number">1</span>)</span><br><span class="line">            s.freeindex = freeidx</span><br><span class="line">            v := gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">            s.allocCount++</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocCache 这里是用位图表示内存是否可用，1 表示可用。然后通过 span 里面的 freeindex 和 elemsize 来计算地址即可。</p><p>如果 mcache.alloc[sizeclass] 已经不够用了，则从 mcentral 申请内存到 mcache。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFree returns the next free object from the cached span if one is available.</span></span><br><span class="line"><span class="comment">// Otherwise it refills the cache with a span with an available object and</span></span><br><span class="line"><span class="comment">// returns that object along with a flag indicating that this was a heavy</span></span><br><span class="line"><span class="comment">// weight allocation. If it is a heavy weight allocation the caller must</span></span><br><span class="line"><span class="comment">// determine whether a new GC cycle needs to be started or if the GC is active</span></span><br><span class="line"><span class="comment">// whether this goroutine needs to assist the GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(sizeclass <span class="keyword">uint8</span>)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    s = c.alloc[sizeclass]</span><br><span class="line">    shouldhelpgc = <span class="literal">false</span></span><br><span class="line">    freeIndex := s.nextFreeIndex()</span><br><span class="line">    <span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">        <span class="comment">// The span is full.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"runtime: s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">            throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 这个地方 mcache 向 mcentral 申请</span></span><br><span class="line">            c.refill(<span class="keyword">int32</span>(sizeclass))</span><br><span class="line">        &#125;)</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        s = c.alloc[sizeclass]</span><br><span class="line">        <span class="comment">// mcache 向 mcentral 申请完之后，再次从 mcache 申请</span></span><br><span class="line">        freeIndex = s.nextFreeIndex()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextFreeIndex returns the index of the next free object in s at</span></span><br><span class="line"><span class="comment">// or after s.freeindex.</span></span><br><span class="line"><span class="comment">// There are hardware instructions that can be used to make this</span></span><br><span class="line"><span class="comment">// faster if profiling warrants it.</span></span><br><span class="line"><span class="comment">// 这个函数和 nextFreeFast 有点冗余了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">nextFreeIndex</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mcache 向 mcentral，如果 mcentral 不够，则向 mheap 申请。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">refill</span><span class="params">(sizeclass <span class="keyword">int32</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 向 mcentral 申请</span></span><br><span class="line">    s = mheap_.central[sizeclass].mcentral.cacheSpan()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a span to use in an MCache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replenish central list if empty.</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">grow</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    npages := <span class="keyword">uintptr</span>(class_to_allocnpages[c.sizeclass])</span><br><span class="line">    size := <span class="keyword">uintptr</span>(class_to_size[c.sizeclass])</span><br><span class="line">    n := (npages &lt;&lt; _PageShift) / size</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里想 mheap 申请</span></span><br><span class="line">    s := mheap_.alloc(npages, c.sizeclass, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 mheap 不足，则想 OS 申请。接上面的代码 mheap_.alloc()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, sizeclass <span class="keyword">int32</span>, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s = h.alloc_m(npage, sizeclass, large)</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, sizeclass <span class="keyword">int32</span>, large <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    s := h.allocSpanLocked(npage)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    s = h.allocLarge(npage)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = h.allocLarge(npage)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">grow</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// Ask for a big chunk, to reduce the number of mappings</span></span><br><span class="line">    <span class="comment">// the operating system needs to track; also amortizes</span></span><br><span class="line">    <span class="comment">// the overhead of an operating system mapping.</span></span><br><span class="line">    <span class="comment">// Allocate a multiple of 64kB.</span></span><br><span class="line">    npage = round(npage, (<span class="number">64</span>&lt;&lt;<span class="number">10</span>)/_PageSize)</span><br><span class="line">    ask := npage &lt;&lt; _PageShift</span><br><span class="line">    <span class="keyword">if</span> ask &lt; _HeapAllocChunk &#123;</span><br><span class="line">        ask = _HeapAllocChunk</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v := h.sysAlloc(ask)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数调用链如上所示，最后 sysAlloc 会调用系统调用（mmap 或者 VirtualAlloc，和初始化那部分有点类似）去向操作系统申请。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>mcache 回收可以分两部分：第一部分是将 alloc 中未用完的内存归还给对应的 mcentral。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freemcache</span><span class="params">(c *mcache)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c.releaseAll()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        purgecachedstats(c)</span><br><span class="line">        mheap_.cachealloc.free(unsafe.Pointer(c))</span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">releaseAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; _NumSizeClasses; i++ &#123;</span><br><span class="line">        s := c.alloc[i]</span><br><span class="line">        <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">            mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">            c.alloc[i] = &amp;emptymspan</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clear tinyalloc pool.</span></span><br><span class="line">    c.tiny = <span class="number">0</span></span><br><span class="line">    c.tinyoffset = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 releaseAll() 负责将 mcache.alloc 中各个 sizeclass 中的 mspan 归还给 mcentral。这里需要注意的是归还给 mcentral 的时候需要加锁，因为 mcentral 是全局的。除此之外将剩下的 mcache （基本是个空壳）归还给 mheap.cachealloc，其实就是把 mcache 插入 free list 表头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fixalloc)</span> <span class="title">free</span><span class="params">(p unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    f.inuse -= f.size</span><br><span class="line">    v := (*mlink)(p)</span><br><span class="line">    v.next = f.list</span><br><span class="line">    f.list = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mcentral-回收"><a href="#mcentral-回收" class="headerlink" title="mcentral 回收"></a>mcentral 回收</h4><p>当 mspan 没有 free object 的时候，将 mspan 归还给 mheap。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">freeSpan</span><span class="params">(s *mspan, preserve <span class="keyword">bool</span>, wasempty <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> s.allocCount != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.nonempty.remove(s)</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    mheap_.freeSpan(s, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mheap-1"><a href="#mheap-1" class="headerlink" title="mheap"></a>mheap</h4><p>mheap 并不会定时向操作系统归还，但是会对 span 做一些操作，比如合并相邻的 span。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>tcmalloc 是一种理论，运用到实践中还要考虑工程实现的问题。学习 Golang 源码的过程中，除了知道它是如何工作的之外，还可以学习到很多有趣的知识，比如使用变量填充 CacheLine 避免 False Sharing，利用 debruijn 序列求解 Trailing Zero（在函数中 sys.Ctz64 使用）等等。我想这就是读源码的意义所在吧。</p><blockquote><p>转载自<a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">http://legendtkl.com/2017/04/02/golang-alloc/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 的内存管理基于 tcmalloc，可以说起点挺高的。但是 Golang 在实现的时候还做了很多优化，我们下面通过源码来看一下 Golang 的内存管理实现。下面的源码分析基于 go1.8rc3。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://github.com/fitzix/categories/Go/"/>
    
    
      <category term="Go" scheme="https://github.com/fitzix/tags/Go/"/>
    
      <category term="Go源码分析" scheme="https://github.com/fitzix/tags/Go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用数据结构和操作</title>
    <link href="https://github.com/fitzix/2017/04/10/redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/fitzix/2017/04/10/redis常用数据结构和操作/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>Redis常用的数据结构有5种 String Hash List Set SortSet</p><a id="more"></a><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>Set name fitz 设置name = fitz 存储</li><li>Get name 获取设置好的name的值</li><li>Setnx name fitz 设置name键值为fitz 如果存在,则返回0 不存在返回1</li><li>Mset name fitz age 23 salary 233333 设置多个键值对 一块存错 全成功,全失败</li><li>Msetnx name fitz age 23 hoby basketball 如果设置多个键值对中有存在返回失败</li><li>Mget name age salary 获取多个键的值</li><li>Getset name fitz 获取name的值,并设置新的值为fitz</li><li>Setrange name 3 fitz 将键name 3字符和面的进行替换 结果为luofitz</li><li>Getrange name 3 6 获取键name的值 结果为luofitz</li><li>Append name .com 给键nane追加.com 结果为fitz.com</li><li>Incr age 设置每个值自增 返回结果为24</li><li>Incrby age 6 给name加上6 如果是负数则键</li><li>Decr 与incr相反</li><li>Decrby 与decrby相反</li><li>Strlen 返回键对应的值得字符长度</li></ul><hr><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul><li>Hset user:001 name fitz    设置哈表名字user 表里面的001 的name 设置为 fitz</li><li>Hsetnx user name maomao    设置哈希表名字中的name 存在,设置不成功</li><li>Hget user:001 name 获取hash表的user的001的值</li><li>Hmset user:003 name maomao age 23 批量设置</li><li>Hmget user:003 name age 批量获取user:003的值</li><li>Hincrby user:003 age 3     给hash表的age值加上3</li><li>Hexists user:003 name 判断hash表中式否存在name的键</li><li>Hlen user:003 返回hash表的所有的字段的数目</li><li>Hkeys user:003 返回hash表的所有字段</li><li>Hvals user:003 返回hash表中所有的值</li><li>Hgetall user:003 返回所有的字段和值</li><li>Hdel user:003 name 对hash的name的值和键删除</li></ul><hr><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>栈:先进后出 队列:先进先出</code></p><ul><li>lpush 从头压入<ul><li>Lpush list1 “world”</li><li>lpush list1 ‘hello”</li><li>Lrange list1 0 -1 把链表中的数据从0到尾全部取出</li></ul></li><li>rpush 从尾部压入<ul><li>rpush list2 “world”</li><li>rpush list2 “luowen”</li><li>lrange list2 0 -1</li></ul></li><li>linsert 插入出入数据<ul><li>Linsert list3 before maomao love</li><li>Lrange list3 0 -1</li><li>Linsert list3 after luowen love</li><li>Lrange list3 0 -1</li></ul></li><li>lset 给某个元素赋值<ul><li>Lset list5 0 “deom”</li></ul></li><li>lrem 删除list表中的数据<ul><li>Lrem list6 1 “luowen”</li></ul></li><li>ltrim 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除<ul><li><code>LTRIM KEY_NAME START STOP</code></li></ul></li><li>lpop 从链表的头部弹出一个元素<ul><li><code>LLEN KEY_NAME</code></li></ul></li><li>rpop 从链表的尾部弹出一个元素<ul><li><code>LLEN KEY_NAME</code></li></ul></li><li>rpoplpush 从一个链表弹出,在从头部压入到另一个链表<ul><li><code>RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME</code></li></ul></li><li>lindex 返回一个list小标的索引值</li><li>llen 返回这个链表的元素的长度</li></ul><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li>sadd 向集合中插入一条数据</li><li>srem 删除集合中的一个元素</li><li>smembers 查看集合中的元素</li><li>spop 从集合随机弹出一个元素,返回键值</li><li>sdiff 两个集合的差集 返回两个集合不一样的,根据第一个集合为标准</li><li>sdiffstroe 将两个差集存储到另外一个集合        </li><li>sinter 将两个集合的交集</li><li>sinterstore 将两个集合的交集存储到另外一个集合中</li><li>sunion 将两个集合并集</li><li>sunionstore 将两个集合并集并存储到另外一个集合中</li><li>smove 将以个集合中的元素移动到另外一个集合中</li><li>scard 查看集合中元素的个数</li><li>sismember 判断是否是集合中的元素</li><li>srandmember myset14 随机取出myset1 中的元素</li></ul><hr><h2 id="SortSet"><a href="#SortSet" class="headerlink" title="SortSet"></a>SortSet</h2><ul><li>zadd 添加到有序集合中区</li><li>zrem 删除有序集合中的元素</li><li>zincrby myzsent luowen1 3将myzsent luown1的序号更改为4 如果没有,就创建他</li><li>zrank 找到myzsent 对应值得索引</li><li>zrevrank 反过来去索引</li><li>zrangebyscore 返回集合中指定的元素</li><li>zcount 返回指定空间的数量</li><li>zcard 返回集合中所有元素的个数</li><li>zremrangbyrank 删除集合中指定区间的元素,并将索引进行排序</li><li>zremrangbyscore 删除集合中指定元素,按循序进行排序</li><li>sadd 向集合中插入一条数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis常用的数据结构有5种 String Hash List Set SortSet&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://github.com/fitzix/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://github.com/fitzix/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis锁的正确姿势</title>
    <link href="https://github.com/fitzix/2017/04/05/redis%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>https://github.com/fitzix/2017/04/05/redis锁的正确姿势/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>redis是php的好朋友，在php写业务过程中，有时候会使用到锁的概念，同时只能有一个人可以操作某个行为。这个时候我们就要用到锁。锁的方式有好几种，php不能在内存中用锁，不能使用zookeeper加锁，使用数据库做锁又消耗比较大，这个时候我们一般会选用redis做锁机制。</p><a id="more"></a><blockquote><p>setnx</p></blockquote><p>锁在redis中最简单的数据结构就是string。最早的时候，上锁的操作一般使用setnx，这个命令是当:lock不存在的时候set一个val，或许你还会记得使用expire来增加锁的过期，解锁操作就是使用del命令，伪代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Redis::setnx(<span class="string">"my:lock"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    Redis::expire(<span class="string">"my:lock"</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line"></span><br><span class="line">    Redis::del(<span class="string">"my:lock"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是有问题的，问题就在于setnx和expire中间如果遇到crash等行为，可能这个lock就不会被释放了。于是进一步的优化方案可能是在lock中存储timestamp。判断timestamp的长短。</p><blockquote><p>set</p></blockquote><p>现在官方建议直接使用set来实现锁。我们可以使用set命令来替代setnx，就是下面这个样子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Redis::set(<span class="string">"my:lock"</span>, <span class="number">1</span>, <span class="string">"nx"</span>, <span class="string">"ex"</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">    ... <span class="keyword">do</span> something</span><br><span class="line"></span><br><span class="line">    Redis::del(<span class="string">"my:lock"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码把my:lock设置为1，当且仅当这个lock不存在的时候，设置完成之后设置过期时间为10。</p><p>获取锁的机制是对了，但是删除锁的机制直接使用del是不对的。因为有可能导致误删别人的锁的情况。</p><p>比如，这个锁我上了10s，但是我处理的时间比10s更长，到了10s，这个锁自动过期了，被别人取走了，并且对它重新上锁了。那么这个时候，我再调用Redis::del就是删除别人建立的锁了。</p><p>官方对解锁的命令也有建议，建议使用lua脚本，先进行get，再进行del</p><p>程序变成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$token = rand(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Redis::set(<span class="string">"my:lock"</span>, $token, <span class="string">"nx"</span>, <span class="string">"ex"</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $script = `</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]</span><br><span class="line">then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end    </span><br><span class="line">    `</span><br><span class="line">    <span class="keyword">return</span> Redis::eval($script, <span class="string">"my:lock"</span>, $token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lock()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的token是一个随机数，当lock的时候，往redis的my:lock中存的是这个token，unlock的时候，先get一下lock中的token，如果和我要删除的token是一致的，说明这个锁是之前我set的，否则的话，说明这个锁已经过期，是别人set的，我就不应该对它进行任何操作。</p><p>所以：不要再使用setnx，直接使用set进行锁实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis是php的好朋友，在php写业务过程中，有时候会使用到锁的概念，同时只能有一个人可以操作某个行为。这个时候我们就要用到锁。锁的方式有好几种，php不能在内存中用锁，不能使用zookeeper加锁，使用数据库做锁又消耗比较大，这个时候我们一般会选用redis做锁机制。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://github.com/fitzix/categories/PHP/"/>
    
    
      <category term="PHP Redis" scheme="https://github.com/fitzix/tags/PHP-Redis/"/>
    
  </entry>
  
  <entry>
    <title>web的请求流程</title>
    <link href="https://github.com/fitzix/2017/03/12/web%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/fitzix/2017/03/12/web请求流程/</id>
    <published>2017-03-11T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>PHP作为世界上最好的编程语音，被广泛的运用到Web开发中。因为其语法和C类似，有着非常平缓的学习曲线，越来越多的人使用PHP进行Web产品的快速开发。PHP世界里也涌现了很多开发框架，比如Laravel、ThinkPHP等，但不论何总框架，他们在处理Web请求时的模式都是一样的，本文首先阐述PHP开发Web应用的基本架构，然后分别分析Laravel和ThinkPHP在处理Web请求时的处理流程。</p><a id="more"></a><h3 id="PHP开发Web应用的基本架构"><a href="#PHP开发Web应用的基本架构" class="headerlink" title="PHP开发Web应用的基本架构"></a>PHP开发Web应用的基本架构</h3><hr><p>PHP开发Web应用时所以的请求需要指向具体的入口文件。WebServer是一个内容分发者，他接受用户的请求后，如果是请求的是css、js等静态文件，WebServer会找到这个文件，然后发送给浏览器；如果请求的是/index.php，根据配置文件，WebServer知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。<br><img src="https://segmentfault.com/img/bVLftp?w=455&amp;h=233" alt="enter image description here"></p><p>WebServer会依据CGI协议，将请求的Url、数据、Http Header等信息发送给PHP解析器，接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。整个处理过程如上图所示。</p><h3 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h3><hr><p>这里的PHP解析器就是实现了CGI协议的程序，每次请求到来时他会解析php.ini文件，初始化执行环境，这就导致PHP解析器性能低下，于是就出现了CGI的改良升级版FastCGI。FastCGI是一种语言无关的协议，用来沟通程序(如PHP, Python, Java)和Web服务器(Apache2, Nginx), 理论上任何语言编写的程序都可以通过FastCGI来提供Web服务。它的特点是会在动态分配处理进程给请求，以达到提高效率的目的，大多数FastCGI实现都会维护一个进程池。FastCGI会先启一个master进程，解析配置文件，初始化执行环境，然后再启动多个worker进程。当请求过来时，master进程会这个请求传递给一个worker进程，然后立即接受下一个请求。而且当worker进程不够用时，master可以根据配置预先启动几个worker进程等待；当然空闲worker进程太多时，也会自动关闭，这样就提高了性能，节约了系统资源。整个过程FastCGI扮演着对CGI进程进行管理的角色。</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><hr><p>PHP-FPM是一个专门针对PHP实现了FastCGI协议的程序，它实际上就是一个PHP FastCGI进程管理器，负责管理一个进程池，调用PHP解析器来处理来自Web服务器的请求。PHP-FPM能够对php.ini文件的修改进行平滑过度。</p><p>新建一个helloworld.php文件，写入下列代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"helloworld,"</span>;    </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"this is my first php script."</span>;</span><br><span class="line">   <span class="keyword">echo</span> phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>配置好WebServer和PHP-FPM等php运行环境后，在浏览器中访问该文件就可以直接得到输出。</p><h3 id="基于PHP的Web框架"><a href="#基于PHP的Web框架" class="headerlink" title="基于PHP的Web框架"></a>基于PHP的Web框架</h3><hr><h4 id="PHP-Web框架是"><a href="#PHP-Web框架是" class="headerlink" title="PHP Web框架是"></a>PHP Web框架是</h4><blockquote><p>基于某模式将PHP开发常用功能封装实现使开发者快速开发的工具</p></blockquote><h4 id="它主要的任务包括："><a href="#它主要的任务包括：" class="headerlink" title="它主要的任务包括："></a>它主要的任务包括：</h4><ul><li>代码重用：定义包、类、函数的放置和加载规则，建议直接整合Composer及其AutoLoad特性。</li><li>请求的分发管理：这个就是路由，Rest风的框架喜欢Rewrite，简单的一点的框架主要通过参数来定位模块和方法所在。</li><li>配置文件管理：加载和动态加载配置数据</li><li>错误和异常管理：异常捕捉、错误日志记录以及错误码规范。</li><li>Layout和模板引擎：如何规划页面布局、widget如何重用、ajax页面如何结合、过期- session如何重定向；数据和模板怎么渲染成HTML，是否压缩和设置过期头。</li><li>数据库：如何融入控制器；支持什么样的driver；考虑主从分离的扩展性；以及是否使用ORM</li></ul><blockquote><h4 id="ThinkPHP3-2框架处理流程分析"><a href="#ThinkPHP3-2框架处理流程分析" class="headerlink" title="ThinkPHP3.2框架处理流程分析"></a>ThinkPHP3.2框架处理流程分析</h4></blockquote><p>TP的设计逻辑就是简单粗暴，面对问题解决问题，所以他的处理流程是基于面向过程的思想，而没有采用面向对象的依赖注入、控制反转等思路。他的自动加载、错误处理通过php原生函数的回调来实现。TP处理每次请求要经过四个步骤如下图所示：<br><img src="https://segmentfault.com/img/bVLfvf?w=189&amp;h=441" alt="enter image description here"></p><h4 id="调用应用路口index-php"><a href="#调用应用路口index-php" class="headerlink" title="调用应用路口index.php"></a>调用应用路口index.php</h4><p>index.php是TP的入口文件，所有的请求都由该文件接管，它的工作也很简单主要是引入ThinkPHP入口文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用入口文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测PHP环境</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(version_compare(PHP_VERSION,<span class="string">'5.3.0'</span>,<span class="string">'&lt;'</span>))  <span class="keyword">die</span>(<span class="string">'require</span></span><br><span class="line"><span class="string"> PHP &gt; 5.3.0 !'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">define(<span class="string">'APP_DEBUG'</span>,<span class="keyword">False</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义应用目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">define(<span class="string">'APP_PATH'</span>,<span class="string">'./Application/'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入ThinkPHP入口文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span></span><br><span class="line"><span class="string">'./ThinkPHP/ThinkPHP.php'</span>;</span><br></pre></td></tr></table></figure><h4 id="载入框架入口文件ThinkPHP-php"><a href="#载入框架入口文件ThinkPHP-php" class="headerlink" title="载入框架入口文件ThinkPHP.php"></a>载入框架入口文件ThinkPHP.php</h4><p>在ThinkPHP.php中主要记录初始运行时间和内存开销，然后完成系统常量判断及定义，最后载入框架引导类（Think\Think）并执行Think::start方法进行应用初始化。</p><h4 id="应用初始化Think-Think-start"><a href="#应用初始化Think-Think-start" class="headerlink" title="应用初始化Think\Think:start()"></a>应用初始化Think\Think:start()</h4><p>应用初始化首先设置错误处理机制和自动加载机制</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注册AUTOLOAD方法</span></span><br><span class="line">      spl_autoload_register(<span class="string">'Think\Think::autoload'</span>);      </span><br><span class="line">      <span class="comment">// 设定错误和异常处理</span></span><br><span class="line">      register_shutdown_function(<span class="string">'Think\Think::fatalError'</span>);</span><br><span class="line">      set_error_handler(<span class="string">'Think\Think::appError'</span>);</span><br><span class="line">      set_exception_handler(<span class="string">'Think\Think::appException'</span>);</span><br></pre></td></tr></table></figure><p>然后加载相关配置文件和运行模式定义文件，最后调用Think\App类的run方法启动应用</p><h4 id="运行应用App-run"><a href="#运行应用App-run" class="headerlink" title="运行应用App::run()"></a>运行应用App::run()</h4><p>此后TP进入请求处理管道，TP为管道中定义了14个事件，每个事件都可以绑定回调函数，请求到达管道后依次触发这些事件，事件触发后就会调用绑定到事件的回调函数，整个管道的生命周期由app_init开始，由app_end结束。具体实现上，TP将这些事件命名为标签（位），也可以称之为钩子，将回调函数命名为行为，当应用程序运行到标签的时候，就会被拦截下来，统一执行相关的行为。</p><blockquote><h3 id="Laravel框架处理流程分析"><a href="#Laravel框架处理流程分析" class="headerlink" title="Laravel框架处理流程分析"></a>Laravel框架处理流程分析</h3></blockquote><h4 id="统一入口"><a href="#统一入口" class="headerlink" title="统一入口"></a>统一入口</h4><p>Laravel框架使用了统一入口，入口文件：/public/index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//自动加载文件设置</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/../bootstrap/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务容器（可以查看一下关于‘服务容器’的相关文档）</span></span><br><span class="line">$app = <span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">'/../bootstrap/app.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过服务容器生成一个kernel类的实例（Illuminate\Contracts\Http\Kernel实际上只是一个接口，真正生成的实例是App\Http\Kernel类，至于怎么把接口和类关联起来，请查看Contracts相关文档）</span></span><br><span class="line">$kernel = $app-&gt;make(<span class="string">'Illuminate\Contracts\Http\Kernel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行Kernel类的handle方法，主要动作是运行middleware和启动URL相关的Contrller</span></span><br><span class="line">$response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制器返回结果之后的操作，暂时还没看，以后补上</span></span><br><span class="line">$response-&gt;send();</span><br><span class="line"></span><br><span class="line">$kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure><h4 id="自动加载文件"><a href="#自动加载文件" class="headerlink" title="自动加载文件"></a>自动加载文件</h4><p>laravel的自动加载，其实也就是Composer的自动加载<br>Composer根据声明的依赖关系，从相关库的源下载代码文件，并根据依赖关系在 Composer 目录下生成供类自动加载的 PHP 脚本，使用的时候，项目开始处引入 “/vendor/autoload.php” 文件，就可以直接实例化这些第三方类库中的类了。</p><h4 id="服务容器——Laravel真正的核心"><a href="#服务容器——Laravel真正的核心" class="headerlink" title="服务容器——Laravel真正的核心"></a>服务容器——Laravel真正的核心</h4><p>服务容器，也叫IoC容器，其实包含了依赖注入(DI)和控制反转(IoC)两部分，是Laravel的真正核心。其他的各种功能模块比如 Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request and Response（请求和响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被使用，其实都是 Laravel 的服务容器负责的。</p><h4 id="启动Kernel代码"><a href="#启动Kernel代码" class="headerlink" title="启动Kernel代码"></a>启动Kernel代码</h4><p>Kernel实例调用handle方法，意味着Laravel的核心和公用代码已经准备完毕，此项目正式开始运行</p><p>代码清单/app/Http/Kernel.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line"><span class="title">App</span>\<span class="title">Http</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span></span><br><span class="line"><span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Http</span>\<span class="title">Kernel</span></span><br><span class="line"><span class="title">as</span></span><br><span class="line"><span class="title">HttpKernel</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Kernel</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">HttpKernel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是在调用路由之前需要启动的中间件,一般都是核心文件，不要修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span></span><br><span class="line">$middleware</span><br><span class="line">=</span><br><span class="line">[</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'Illuminate\Cookie\Middleware\EncryptCookies'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'Illuminate\Session\Middleware\StartSession'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'Illuminate\View\Middleware\ShareErrorsFromSession'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'App\Http\Middleware\VerifyCsrfToken'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是我们在router.php文件里面或者Controller文件里面，可以使用的Middleware元素，可以自定义加入很多</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span></span><br><span class="line">$routeMiddleware</span><br><span class="line">=</span><br><span class="line">[</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'auth'</span></span><br><span class="line">=&gt;</span><br><span class="line"><span class="string">'App\Http\Middleware\Authenticate'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'auth.basic'</span></span><br><span class="line">=&gt;</span><br><span class="line"><span class="string">'Illuminate\Auth\Middleware\AuthenticateWithBasicAuth'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'guest'</span></span><br><span class="line">=&gt;</span><br><span class="line"><span class="string">'App\Http\Middleware\RedirectIfAuthenticated'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">'test'</span></span><br><span class="line">=&gt;</span><br><span class="line"><span class="string">'App\Http\Middleware\testMiddleWare'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实这个文件里面没有handle方法，只有一些属性定义，所以真正的handle方法，实在父类里面实现的</p><p>代码清单…/Illuminate/Foundation/Http/Kernel.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//这个很重要，是项目的一些启动引导项，Kernel的重要步骤中，首先就是启动这些文件的bootstrap方法</span><br><span class="line">protected $bootstrappers = [</span><br><span class="line">        //检测环境变量文件是否正常</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\DetectEnvironment&apos;,</span><br><span class="line">        //取得配置文件，即把/config/下的所有配置文件读取到容器（app()-&gt;make(&apos;config&apos;)可以查看所有配置信息）</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\LoadConfiguration&apos;,</span><br><span class="line">        //绑定一个名字为log的实例到容器，怎么访问？？（app()-&gt;make(&apos;log&apos;)）</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\ConfigureLogging&apos;,</span><br><span class="line">        //设置异常抓取信息，这个还没仔细看，但大概就是这个意思</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\HandleExceptions&apos;,</span><br><span class="line">        //把/config/app.php里面的aliases项利用PHP库函数class_alias创建别名，从此，我们可以使用App::make(&apos;app&apos;)方式取得实例</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\RegisterFacades&apos;,</span><br><span class="line">        //把/config/app.php里面的providers项,注册到容器</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\RegisterProviders&apos;,</span><br><span class="line">        //运行容器中注册的所有的ServiceProvider中得boot方法</span><br><span class="line">        &apos;Illuminate\Foundation\Bootstrap\BootProviders&apos;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  //真正的handle方法</span><br><span class="line">  public function handle($request)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //主要是这行，调度了需要运行的方法</span><br><span class="line">            return $this-&gt;sendRequestThroughRouter($request);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception $e)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;reportException($e);</span><br><span class="line">            return $this-&gt;renderException($request, $e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected function sendRequestThroughRouter($request)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;app-&gt;instance(&apos;request&apos;, $request);</span><br><span class="line">        Facade::clearResolvedInstance(&apos;request&apos;);</span><br><span class="line">        //运行上述$bootstrappers里面包含的文件的bootstrap方法，运行的作用，上面已经注释</span><br><span class="line">        $this-&gt;bootstrap();</span><br><span class="line">        //这是在对URL进行调度之前，也就是运行Route之前，进行的一些准备工作</span><br><span class="line">        return (new Pipeline($this-&gt;app))    </span><br><span class="line">                    -&gt;send($request)        </span><br><span class="line">                    //需要运行$this-&gt;middleware里包含的中间件</span><br><span class="line">                    -&gt;through($this-&gt;middleware)</span><br><span class="line">                    //运行完上述中间件之后，调度dispatchToRouter方法，进行Route的操作</span><br><span class="line">                    -&gt;then($this-&gt;dispatchToRouter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前奏执行完毕之后，进行Route操作</span><br><span class="line">    protected function dispatchToRouter()</span><br><span class="line">    &#123;</span><br><span class="line">        return function($request)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;app-&gt;instance(&apos;request&apos;, $request);</span><br><span class="line">            //跳转到Router类的dispatch方法</span><br><span class="line">            return $this-&gt;router-&gt;dispatch($request);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面就需要根据URL和/app/Http/routes.php文件，进行Route操作</p><p>文件清单…/Illuminate/Routing/Router.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">function</span><br><span class="line">dispatch(Request</span><br><span class="line">$request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$this-&gt;currentRequest</span><br><span class="line">=</span><br><span class="line">$request;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在4.2版本里面，Route有一个筛选属性；5.0之后的版本，被Middleware代替</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response</span><br><span class="line">=</span><br><span class="line">$this-&gt;callFilter(&apos;before&apos;,</span><br><span class="line">$request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if</span><br><span class="line">(is_null($response))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//继续调度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response</span><br><span class="line">=</span><br><span class="line">$this-&gt;dispatchToRoute($request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response</span><br><span class="line">=</span><br><span class="line">$this-&gt;prepareResponse($request,</span><br><span class="line">$response);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在4.2版本里面，Route有一个筛选属性；5.0之后的版本，被Middleware代替</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$this-&gt;callFilter(&apos;after&apos;,</span><br><span class="line">$request,</span><br><span class="line">$response);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$response;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public</span><br><span class="line">function</span><br><span class="line">dispatchToRoute(Request</span><br><span class="line">$request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$route</span><br><span class="line">=</span><br><span class="line">$this-&gt;findRoute($request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$request-&gt;setRouteResolver(function()</span><br><span class="line">use</span><br><span class="line">($route)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$route;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$this-&gt;events-&gt;fire(&apos;router.matched&apos;,</span><br><span class="line">[$route,</span><br><span class="line">$request]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response</span><br><span class="line">=</span><br><span class="line">$this-&gt;callRouteBefore($route,</span><br><span class="line">$request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if</span><br><span class="line">(is_null($response))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"> 只看这一行，还是调度文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response</span><br><span class="line">=</span><br><span class="line">$this-&gt;runRouteWithinStack(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$route,</span><br><span class="line">$request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response</span><br><span class="line">=</span><br><span class="line">$this-&gt;prepareResponse($request,</span><br><span class="line">$response);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$this-&gt;callRouteAfter($route,</span><br><span class="line">$request,</span><br><span class="line">$response);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$response;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected</span><br><span class="line">function</span><br><span class="line">runRouteWithinStack(Route</span><br><span class="line">$route,</span><br><span class="line">Request</span><br><span class="line">$request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"> 取得routes.php里面的Middleware节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$middleware</span><br><span class="line">=</span><br><span class="line">$this-&gt;gatherRouteMiddlewares($route);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这个有点眼熟</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">(new</span><br><span class="line">Pipeline($this-&gt;container))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt;send($request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//执行上述的中间件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt;through($middleware)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt;then(function($request)</span><br><span class="line">use</span><br><span class="line">($route)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//到Controller类了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$this-&gt;prepareResponse(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$request,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//run控制器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$route-&gt;run($request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public</span><br><span class="line">function</span><br><span class="line">run(Request</span><br><span class="line">$request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$this-&gt;container</span><br><span class="line">=</span><br><span class="line">$this-&gt;container</span><br><span class="line">?:</span><br><span class="line">new</span><br><span class="line">Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if</span><br><span class="line">(</span><br><span class="line">!</span><br><span class="line">is_string($this-&gt;action[&apos;uses&apos;]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$this-&gt;runCallable($request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if</span><br><span class="line">($this-&gt;customDispatcherIsBound())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实际上是运行了这行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$this-&gt;runWithCustomDispatcher($request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//其实我是直接想运行这行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$this-&gt;runController($request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">catch</span><br><span class="line">(HttpResponseException</span><br><span class="line">$e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$e-&gt;getResponse();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//继续调度，最终调度到.../Illuminate/Routing/ControllerDispatcher.php文件的dispatch方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected</span><br><span class="line">function</span><br><span class="line">runWithCustomDispatcher(Request</span><br><span class="line">$request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list($class,</span><br><span class="line">$method)</span><br><span class="line">=</span><br><span class="line">explode(&apos;@&apos;,</span><br><span class="line">$this-&gt;action[&apos;uses&apos;]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$dispatcher</span><br><span class="line">=</span><br><span class="line">$this-&gt;container-&gt;make(&apos;illuminate.route.dispatcher&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">$dispatcher-&gt;dispatch($this,</span><br><span class="line">$request,</span><br><span class="line">$class,</span><br><span class="line">$method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件清单…/Illuminate/Routing/ControllerDispatcher.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">function</span><br><span class="line">dispatch(Route</span><br><span class="line">$route,</span><br><span class="line">Request</span><br><span class="line">$request,</span><br><span class="line">$controller,</span><br><span class="line">$method)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $instance</span><br><span class="line">=</span><br><span class="line">$this-&gt;makeController($controller);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $this-&gt;assignAfter($instance,</span><br><span class="line">$route,</span><br><span class="line">$request,</span><br><span class="line">$method);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $response</span><br><span class="line">=</span><br><span class="line">$this-&gt;before($instance,</span><br><span class="line">$route,</span><br><span class="line">$request,</span><br><span class="line">$method);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if</span><br><span class="line">(is_null($response))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //还要调度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            $response</span><br><span class="line">=</span><br><span class="line">$this-&gt;callWithinStack(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                $instance,</span><br><span class="line">$route,</span><br><span class="line">$request,</span><br><span class="line">$method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">$response;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected</span><br><span class="line">function</span><br><span class="line">callWithinStack($instance,</span><br><span class="line">$route,</span><br><span class="line">$request,</span><br><span class="line">$method)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //又是Middleware......有没有忘记，官方文档里面Middleware可以加在控制器的构造函数中！！没错，这个Middleware就是在控制器里面申明的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $middleware</span><br><span class="line">=</span><br><span class="line">$this-&gt;getMiddleware($instance,</span><br><span class="line">$method);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //又是这个，眼熟吧</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">(new</span><br><span class="line">Pipeline($this-&gt;container))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    -&gt;send($request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    //再次运行Middleware</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    -&gt;through($middleware)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    -&gt;then(function($request)</span><br><span class="line">use</span><br><span class="line">($instance,</span><br><span class="line">$route,</span><br><span class="line">$method)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#123;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        运行控制器，返回结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        return</span><br><span class="line">$this-&gt;call($instance,</span><br><span class="line">$route,</span><br><span class="line">$method);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>终于到达控制器</p><blockquote><p>转自：<a href="http://www.eurekao.com/PHP-processing-web-request-analysis/" target="_blank" rel="noopener">http://www.eurekao.com/PHP-processing-web-request-analysis/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP作为世界上最好的编程语音，被广泛的运用到Web开发中。因为其语法和C类似，有着非常平缓的学习曲线，越来越多的人使用PHP进行Web产品的快速开发。PHP世界里也涌现了很多开发框架，比如Laravel、ThinkPHP等，但不论何总框架，他们在处理Web请求时的模式都是一样的，本文首先阐述PHP开发Web应用的基本架构，然后分别分析Laravel和ThinkPHP在处理Web请求时的处理流程。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://github.com/fitzix/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://github.com/fitzix/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Vue目录结构</title>
    <link href="https://github.com/fitzix/2017/02/06/vuex/"/>
    <id>https://github.com/fitzix/2017/02/06/vuex/</id>
    <published>2017-02-05T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vuex目录结构"><a href="#vuex目录结构" class="headerlink" title="vuex目录结构"></a>vuex目录结构</h2><blockquote><p>|–modules <br><br>  |—–saerch.js <br><br>  |—–searchGrouop.js <br><br>  |–actions.js <br><br>  |–getters.js <br><br>  |–middlewares.js <br><br>  |–mutation-types.js <br><br>  |–store.js <br></p></blockquote><h3 id="各文件使用说明"><a href="#各文件使用说明" class="headerlink" title="各文件使用说明"></a>各文件使用说明</h3><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>module 也就是vuex概念里的store,这里模块拆分了,存放我们实际项目中要使用的vuex模块,一般可以针对组件级别定义.<br>例如这里我们定义了search.js和searchGroup.js 然而module最后会在store.js中统一使用</p><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>这里定义我们vue组件要操作的动作事件, 比如请求一个异步操作,获取其他组件的状态等</p><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>getters 定义公用的getters处理 ,例如正常组件里想computed一个状态但在vuex里面不知道怎么处理，就可以在这里处理</p><h4 id="middlewares"><a href="#middlewares" class="headerlink" title="middlewares"></a>middlewares</h4><p>middlewares中间件处理的东西，这里主要开发时候在控制台查看一些处理日志，vuex本身自带,其他没有研究过</p><h4 id="mutation-types"><a href="#mutation-types" class="headerlink" title="mutation-types"></a>mutation-types</h4><p>定义mutation里用到的方法常量值，统一处理在这里，一般都是业务字符串常量</p><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>store.js核心文件，这里就是vuex基本的写法了，先引用vue和vuex 然后user(Vuex),把定义好的modules,middlewares引入进来然后返回一个Vuex.stor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vuex目录结构&quot;&gt;&lt;a href=&quot;#vuex目录结构&quot; class=&quot;headerlink&quot; title=&quot;vuex目录结构&quot;&gt;&lt;/a&gt;vuex目录结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;|–modules &lt;br&gt;&lt;br&gt;  |—–saerch.js 
      
    
    </summary>
    
      <category term="Vue" scheme="https://github.com/fitzix/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://github.com/fitzix/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>你好2017</title>
    <link href="https://github.com/fitzix/2017/01/01/%E4%BD%A0%E5%A5%BD2017/"/>
    <id>https://github.com/fitzix/2017/01/01/你好2017/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在是17年 好久没有更新博客了 想起来从15年暑假来北京实习到现在已经1年多了 经历了很多 慢慢也成长了 一直有很多话想说 真要写的时候有发现无从写起</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;现在是17年 好久没有更新博客了 想起来从15年暑假来北京实习到现在已经1年多了 经历了很多 慢慢也成长了 一直有很多话想说 真要写的时候有发现无从写起&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="https://github.com/fitzix/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Essay" scheme="https://github.com/fitzix/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>MyINAM与Innodb的区别</title>
    <link href="https://github.com/fitzix/2015/09/23/difference_of_MyISAM_and_Innodb/"/>
    <id>https://github.com/fitzix/2015/09/23/difference_of_MyISAM_and_Innodb/</id>
    <published>2015-09-22T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能</p><p>以下是一些细节和具体实现的差别：<br><a id="more"></a></p><p>◆1.InnoDB不支持FULLTEXT类型的索引。</p><p>◆2.InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</p><p>◆3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p><p>◆4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p><p>◆5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p><p>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁.而MyISAM不支持.所以MyISAM往往就容易被人认为只适合在小项目中使用。</p><p>　　我作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，但是从我目前运维的数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是我的首选。</p><p>　　原因如下：</p><p>　　1、首先我目前平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p><p>　　2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p><p>　　3、从平台角度来说，经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为我平台上最小的一个数据库实例的数据量基本都是几十G大小。</p><p>　　4、从我接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。</p><p>　　5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。</p><p>　　6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。</p><p>　　7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。</p><p>　　当然Innodb也不是绝对不用，用事务的项目如模拟炒股项目，我就是用Innodb的，活跃用户20多万时候，也是很轻松应付了，因此我个人也是很喜欢Innodb的，只是如果从数据库平台应用出发，我还是会首选MyISAM。</p><p>　　另外，可能有人会说你MyISAM无法抗太多写操作，但是我可以通过架构来弥补，说个我现有用的数据库平台容量：主从数据总量在几百T以上，每天十多亿 pv的动态页面，还有几个大项目是通过数据接口方式调用未算进pv总数，(其中包括一个大项目因为初期memcached没部署,导致单台数据库每天处理 9千万的查询)。而我的整体数据库服务器平均负载都在0.5-1左右。<br>　　[end]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能&lt;/p&gt;
&lt;p&gt;以下是一些细节和具体实现的差别：&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://github.com/fitzix/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://github.com/fitzix/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何正常转换中文json格式字符串</title>
    <link href="https://github.com/fitzix/2015/07/09/use_json_note/"/>
    <id>https://github.com/fitzix/2015/07/09/use_json_note/</id>
    <published>2015-07-08T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>如何对json格式的字符串进行转换，在php手册中提供了两个函数：</p><blockquote><p>json_encode : 对变量进行 JSON 编码</p></blockquote><blockquote><p>json_decode : 对 JSON 格式的字符串进行编码</p></blockquote><a id="more"></a><p>下面看个实例：</p><pre><code>$arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];echo json_encode($arr);</code></pre><p>输出为：</p><blockquote><p>[“a”,”b”,”c”]</p></blockquote><p>但是，当我们在数组中放入中文的时候，就会出现问题：</p><pre><code>$arr = [    &apos;世界&apos;,    &apos;你好&apos;,];echo json_encode($arr);</code></pre><p>输出的结果为：</p><blockquote><p>[“\u4e16\u754c”,”\u4f60\u597d”]</p></blockquote><p>这个结果显然不是我们想要的，但是为什么出现这个呢？<br>因为当我们的值中包含中文时，php对他进行json编码时底层会对中文进行unicode编码，导致结果不可读.</p><p><em><strong>那该怎么解决呢？</strong></em></p><p>###方法一<br>可以利用 urlencode 和 urldecode 方法绕过这个转码为 unicode 的过程，先将中文字段进行urlencode，然后json_encode，最后再用urldecode处理结果，便可以正常显示中文。具体代码如下：</p><pre><code>$arr = [    &apos;世界&apos;,    &apos;你好&apos;,];echo urldecode(json_encode(array_map(&apos;urlencode&apos;, $arr)));</code></pre><p>输出结果为：</p><blockquote><p>[“世界”,”你好”]</p></blockquote><p>###方法二<br>自PHP5.4版本，官方就已经给Json新增了一个选项: <code>JSON_UNESCAPED_UNICODE</code>。加上这个选项后，就不会自动把中文编码了。具体代码如下：</p><pre><code>$arr = [    &apos;世界&apos;,    &apos;你好&apos;,];echo json_encode($arr, JSON_UNESCAPED_UNICODE);</code></pre><p>输出为：</p><blockquote><p>[“世界”,”你好”]</p></blockquote><p>看吧，这才是我们想要的结果 :)</p><p>###<strong>注意</strong><br>需要我们注意的是，由于 <code>json_encode</code> 和 <code>json_decode</code>只支持<code>utf-8</code>编码的字符，<code>gbk</code>的字符想要用json函数的话就得转换一下喽。</p><p>[end]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何对json格式的字符串进行转换，在php手册中提供了两个函数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;json_encode : 对变量进行 JSON 编码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;json_decode : 对 JSON 格式的字符串进行编码&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="php" scheme="https://github.com/fitzix/categories/php/"/>
    
    
      <category term="php" scheme="https://github.com/fitzix/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>如何在MySQL中高效的存储ip地址</title>
    <link href="https://github.com/fitzix/2015/06/20/mysql_save_ip/"/>
    <id>https://github.com/fitzix/2015/06/20/mysql_save_ip/</id>
    <published>2015-06-19T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>在多数场景下，我们一般在MySQL中存储ip地址时都使用<code>varchar(15)</code>或者<code>char(15)</code>类型，是吧？<br>虽说功能是实现了，但是这样构建数据表就能最大限度的优化数据库性能吗？答案是否定的，尽管在存储ip上折腾下不会马上提升系统的性能，但是整个系统架构谁又敢说不是各个地方一点点的优化性能给提升起来了呢？所以说巧存ip也是不可忽略的。</p><a id="more"></a><p>###如何高效存储ip</p><p>答案是使用int(10)类型。</p><p>在MySQL中没有专门提供存储ip地址的类型，那我们最容易想到的就是使用<code>varchar(15)</code>和<code>char(15)</code>了，但这样却不怎么高效，为什么呢？因为使用字符串存储的话首先就会占用至少15个字节，然而使用空间也比较大，假设使用int类型的话只会占用4个字节，占用空间少，检索起来也比字符串速度快很多。</p><p>那么，问题来了，我们如何把ip和整型很好地结合起来进行转化呢？幸好mysql已经帮我们实现了这一功能，的确是这样的。mysql中内置了<code>inet_aton()</code>和<code>inet_ntoa()</code>函数可以让ip地址和整形之间很好的转化。</p><p>下面看看mysql手册里的解释吧。</p><p><strong>inet_aton()</strong></p><blockquote><p>INET_ATON(expr)</p></blockquote><blockquote><p>Given the dotted-quad representation of an IPv4 network address as a<br>string, returns an integer that represents the numeric value of the<br>address in network byte order (big endian). INET_ATON() returns NULL if<br>it does not understand its argument.</p></blockquote><p><strong>inet_ntoa()</strong></p><blockquote><p>INET_NTOA(expr)</p></blockquote><blockquote><p>Given a numeric IPv4 network address in network byte order, returns the<br>dotted-quad string representation of the address as a nonbinary string<br>in the connection character set. INET_NTOA() returns NULL if it does<br>not understand its argument.</p></blockquote><p>还是看下实际的例子比较直观：</p><pre><code>&gt; select inet_aton(&apos;192.168.1.100&apos;);</code></pre><p><img src="../../images/201506/2015-06-20_004736.jpg" alt="pic"></p><p>当输入错误的ip地址时会返回NULL:</p><pre><code>&gt; select inet_aton(&apos;a.b.c&apos;);</code></pre><p><img src="../../images/201506/2015-06-20_005013.jpg" alt="pic"></p><p>当从整型转为ip时就可以使用<code>inet_ntoa()</code>函数：</p><pre><code>&gt; select inet_ntoa(3232235876);</code></pre><p><img src="../../images/201506/2015-06-20_005338.jpg" alt="pic"></p><p>当ip不存在时，可以使用0来代替：</p><pre><code>&gt; select inet_ntoa(0);</code></pre><p><img src="../../images/201506/2015-06-20_005428.jpg" alt="pic"></p><p>所以IP的表字段可以设置为INT(10)就好，如果IP获取不到可以直接存0代表获取不到IP的意思.</p><p>好了，这也不是什么很高深的东西，单纯做个笔记而已。</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多数场景下，我们一般在MySQL中存储ip地址时都使用&lt;code&gt;varchar(15)&lt;/code&gt;或者&lt;code&gt;char(15)&lt;/code&gt;类型，是吧？&lt;br&gt;虽说功能是实现了，但是这样构建数据表就能最大限度的优化数据库性能吗？答案是否定的，尽管在存储ip上折腾下不会马上提升系统的性能，但是整个系统架构谁又敢说不是各个地方一点点的优化性能给提升起来了呢？所以说巧存ip也是不可忽略的。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://github.com/fitzix/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://github.com/fitzix/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>一道面试题引发的一点点思考</title>
    <link href="https://github.com/fitzix/2015/06/12/shuffle_array_note/"/>
    <id>https://github.com/fitzix/2015/06/12/shuffle_array_note/</id>
    <published>2015-06-11T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>到了大三下学期，身边的小伙伴都不约而同地开始找实习了，其中面试当然是不可缺少的重头戏啦。<br>最近在面百度的时候，面试官的一道关于随机数的题很有意思，不算难，但却在那么一瞬间触动了我，所以打算抽点时间把它记录下来。（关于它怎么触动我了，最后我会有说明 :P）</p><a id="more"></a><p>###面试题的描述</p><p>大意是这样的：</p><blockquote><p>写一个方法，把给定数组内的元素打乱返回，尽量高效实现。</p></blockquote><p>首先，我想到的就是PHP自带的一个<code>shuffle</code>函数，就是专门干这个事儿的，随机打乱数组，而且是引用传值的。</p><p>当我说出可以使用shuffle函数时，面试官打断了我，说不能使用PHP自带的函数，让自己尝试着实现这个功能。当时很郁闷，明明有高度优化好的方法摆在那却不让用，唉…</p><p>然后，就发动脑袋想吧，想到既然在数组中不管是取值、打印还是赋值都是拿数组的下标操作的，所以我可以往数组下标这方面想，假如我可以打乱下标那不就解决了打乱数组了吗，于是就有了下面比较笨的代码，现在再回头看当时头脑发晕的解决方案，真是无语：</p><pre><code>&lt;?php$arrData = array(&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;, &apos;ddd&apos;, &apos;eee&apos;);$keys = array_keys($arrData);shuffle($keys);$kLen = count($keys);$arrRes = array();foreach($keys as $v){    array_push($arrRes, $arrData[$v]);}var_dump($arrRes);</code></pre><p>尽管功能是实现了，但是其中还是使用了<code>shuffle</code>方法，这显然是不合格的。那种紧张情况下，我能想到的就这个思路了，汗~~</p><p>最后，没辙了，我就大胆问了下面试官能不能给一些提示，那个面试官真的很nice，然后就给出了提示：</p><blockquote><p>说我往数组下标方面思考是正确的，既然要求要高效就意味着在同一个数组中完成操作，可以尝试着使用交换来完成。</p></blockquote><p>对于一道面试题来说，面试官能提示这么多就已经很好了，然后我就顺着这个思路想下去，如果每次随机获取一个下标，然后把该下标对应的value与数组最后一个value交换，最后数组长度减一，接着重复执行上述步骤就可以了。</p><p>下面还是用图来说明下吧，毕竟一图胜千言嘛~~</p><p>假设随机拿到该数组的一个key为1，然后让key为1的元素与最后一个元素（key为4）交换</p><p><img src="https://ws3.sinaimg.cn/large/b09f1c9dly1g1vlz2msssj20mv07dt9b.jpg" alt="2015-06-12_223756"></p><p>第一次交换后，数组长度减一，然后只需要对（数组长度-1）的元素执行相同操作即可。代码如下：</p><pre><code>&lt;?php$arrData = array(&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;, &apos;ddd&apos;, &apos;eee&apos;);$arrLen = count($arrData)-1;while($arrLen &gt;= 0){    $k = mt_rand(0, $arrLen);    $tmp = $arrData[$arrLen];    $arrData[$arrLen] = $arrData[$k];    $arrData[$k] = $tmp;    $arrLen--;}var_dump($arrData);</code></pre><p>这样很好地就解决了这个问题。</p><p>###总结</p><p>其实写这篇博客的目的并不是要记录这道面试题多么多么难，细想想的话怎么都不算难，对吧？其实，写这篇博客的原由是这样的，当我们在面试的时候，不可能都一帆风顺的，多少都会遇到几个棘手的面试题，你想想面试官的心态，肯定要考倒你的啊，当我们没有思路的时候，不要立刻就说不会或者其他放弃作答的话（想想这给面试官传递的信息对自己有多不利！），可以尝试着向面试官要一些解答提示，一般面试官都很好的，都会给出一些思路，然后你就顺着这个思路想下去，最后也许就柳暗花明了，又能给面试官很好的印象，何乐而不为呢？面试官往往并不是一定要得到正确答案，他们真正在乎的也许是你的思考方式。就像我，刚开始可能也没什么很好的解决办法，但是顺着他的思路一步步就那么把正确方法给做出来了。所以，下次再遇到难题，不妨向面试官要一些提示，记住啊~~</p><p>ps：呼应开头，触动我的理由想必大家都已清楚了吧。</p><p>（end）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到了大三下学期，身边的小伙伴都不约而同地开始找实习了，其中面试当然是不可缺少的重头戏啦。&lt;br&gt;最近在面百度的时候，面试官的一道关于随机数的题很有意思，不算难，但却在那么一瞬间触动了我，所以打算抽点时间把它记录下来。（关于它怎么触动我了，最后我会有说明 :P）&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://github.com/fitzix/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://github.com/fitzix/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中使用binary查询字符串</title>
    <link href="https://github.com/fitzix/2015/06/07/mysql_str_binary/"/>
    <id>https://github.com/fitzix/2015/06/07/mysql_str_binary/</id>
    <published>2015-06-06T16:00:00.000Z</published>
    <updated>2019-04-23T04:52:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>今天，在做老师布置的实验作业时候遇到一个关于MySQL字符串比较问题。场景是这样的，就是需要在数据库中查询记录而进行字符串比较时，需要对字符串进行大小写区分比较，这样在默认情况下进行操作可能不会达到你想要的效果。比如下面实例：</p><pre><code>SELECT *　FROM user where username=&apos;maratrix&apos;;SELECT * FROM user where username=&apos;MARATRIX&apos;;</code></pre><p>经测试，发现上面两条SQL语句的执行结果是一样的，这个结果并不是我们想要的，怎么解决？</p><a id="more"></a><p>###问题探究</p><p>在我看来，做技术有一点要清楚的是：<strong><em>解决问题一定要抓住问题的本源，从而游刃有余</em></strong>。下面，我们看看这个小问题是咋回事的呢？</p><p>通过看MySQL手册可以知道，默认情况下，对MySQL数据库中的字段进行查询或者排序都是不区分大小写的。</p><p>但是在有些应用中，需要进行区分大小写的操作，咋办？ </p><p><strong>答：使用BINARY操作符</strong>。</p><blockquote><p>BINARY操作符将后面的字符串抛给一个二进制字符串。这是一种简单的方式来促使逐字节而不是逐字符的进行列比较。这使得比较区分大小写，即使该列不被定义为 BINARY或 BLOB。</p></blockquote><blockquote><p>BINARY影响整个比较；它可以在任何操作数前被给定，而产生相同的结果。</p></blockquote><p>###解决方法</p><p>1、第一种是在创建表结构时候使用binary属性来定义字段：</p><pre><code>create table if not exists user(    id int unsigned primary key auto_increment,    name varchar(32) binary,)engine=myisam;</code></pre><p>或者在表结构创建好后使用alter来添加字段binary属性</p><pre><code>alter table user modify name varchar(32) binary ;</code></pre><p>2、第二种方法是在sql语句中使用bianry来进行区分大小写操作：</p><pre><code>SELECT * FROM user where name=binary &apos;maratrix&apos;;或者SELECT * FROM user where binary name=&apos;maratrix&apos;;</code></pre><p>进过测试发现，使用<code>SELECT * FROM user where name=binary &#39;maratrix&#39;;</code>效率更高点，原因是将binary放在字符串前会使用索引（假设该字段存在索引），而将binary放在字段前面将不会使用索引，即使索引存在也不会使用。</p><p>###注意</p><p>在一些语境中，假如你将一个编入索引的列派给BINARY, MySQL 将不能有效使用这个索引。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，在做老师布置的实验作业时候遇到一个关于MySQL字符串比较问题。场景是这样的，就是需要在数据库中查询记录而进行字符串比较时，需要对字符串进行大小写区分比较，这样在默认情况下进行操作可能不会达到你想要的效果。比如下面实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT *　FROM user where username=&amp;apos;maratrix&amp;apos;;
SELECT * FROM user where username=&amp;apos;MARATRIX&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经测试，发现上面两条SQL语句的执行结果是一样的，这个结果并不是我们想要的，怎么解决？&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://github.com/fitzix/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://github.com/fitzix/tags/mysql/"/>
    
  </entry>
  
</feed>
