<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Fitzix</title><meta name="description" content="Fitzix Hexo Bolg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/fitzix/atom.xml" title="Fitzix"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/14334411?s=460&amp;v=4" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fitzix" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/19/Go中interface的内存布局/" class="post-title-link">Go中interface的内存布局</a></h2><div class="tags"><a href="/tags/Go/" class="tag-title">#Go</a></div><div class="post-info">Mar 19, 2019</div><div class="post-content"><p>一直以来对interface的底层结构及内存布局不了解，只是单纯的转换和使用。今天就遇到了关于interface内存布局的问题，没有答上来，查了查资料和源码，记录一下。</p></div><a href="/2019/03/19/Go中interface的内存布局/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/26/Redis持久化/" class="post-title-link">Redis持久化</a></h2><div class="tags"><a href="/tags/Redis/" class="tag-title">#Redis</a><a href="/tags/RDB/" class="tag-title">#RDB</a><a href="/tags/AOF/" class="tag-title">#AOF</a></div><div class="post-info">Dec 26, 2018</div><div class="post-content"><blockquote>
<p>持久化是将程序数据在持久状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）</p>
</blockquote></div><a href="/2018/12/26/Redis持久化/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/25/Redis内存淘汰策略/" class="post-title-link">Redis内存淘汰策略</a></h2><div class="tags"><a href="/tags/Redis/" class="tag-title">#Redis</a><a href="/tags/LRU/" class="tag-title">#LRU</a></div><div class="post-info">Nov 25, 2018</div><div class="post-content"><p>当Redis被用作缓存的时候，当往Redis中添加新的数据，但是内存不足时，使用lru测试自动清除老的数据, 这几乎是所有缓存应用的默认特性. 事实上,LRU只是redis支持的淘汰策略的其中一种</p></div><a href="/2018/11/25/Redis内存淘汰策略/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/10/22/AVL平衡二叉树中旋转/" class="post-title-link">AVL平衡二叉树中旋转</a></h2><div class="tags"><a href="/tags/AVL/" class="tag-title">#AVL</a></div><div class="post-info">Oct 22, 2018</div><div class="post-content"><p>最近面试被问到平衡二叉树如何保证平衡即失衡后是如何调整的, 之前也只是在leetcode上做过判断是否为平衡二叉树和树的深度搜索之类的题目,对AVL保证平衡的旋转方法及实现并不不了解,所以答不上来.回去后仔细了解了下,记录一下.</p></div><a href="/2018/10/22/AVL平衡二叉树中旋转/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/16/channel底层原理/" class="post-title-link">channel底层原理</a></h2><div class="tags"><a href="/tags/go/" class="tag-title">#go</a><a href="/tags/channel/" class="tag-title">#channel</a></div><div class="post-info">Aug 16, 2018</div><div class="post-content"><p>Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles在goroutine的通信和同步中承担着重要的角色。</p></div><a href="/2018/08/16/channel底层原理/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/06/10/Goroutine的调度/" class="post-title-link">Goroutine的调度</a></h2><div class="tags"></div><div class="post-info">Jun 10, 2018</div><div class="post-content"><p>一直以来对Go internals的都不了解,面试也经常会遇到goroutine的调度问题,当时并不是很清楚,回来以后查阅资料,现整理出来备忘.</p></div><a href="/2018/06/10/Goroutine的调度/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/17/go-file-system-method/" class="post-title-link">Go文件操作</a></h2><div class="tags"><a href="/tags/go/" class="tag-title">#go</a><a href="/tags/golang/" class="tag-title">#golang</a><a href="/tags/filesystem/" class="tag-title">#filesystem</a></div><div class="post-info">Apr 17, 2018</div><div class="post-content"><p>Go官方库的文件操作分散在多个包中，比如<code>os</code>、<code>ioutil</code>包,发现已经有人2015年已经写了一篇这样的文章，写的非常好，我经常在需要使用文件方法的时候回过来查,所以翻译成了中文，记录一下.<br>原文<a href="https://www.devdungeon.com/content/working-files-go#write_bytes" target="_blank" rel="noopener"> Working with Files in Go</a>, 作者<a href="https://www.devdungeon.com/blogs/nanodano" target="_blank" rel="noopener"> NanoDano</a></p></div><a href="/2018/04/17/go-file-system-method/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/16/算法-经典的Top-K问题/" class="post-title-link">[算法]经典的Top-K问题</a></h2><div class="tags"><a href="/tags/算法/" class="tag-title">#算法</a></div><div class="post-info">Apr 16, 2018</div><div class="post-content"><p>什么是 Top K 问题？简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数。<br>这个问题也是十分经典的算法问题，不论是面试中还是实际开发中，都非常典型。而这个问题其实也有很多种做法，你真的都懂了么？</p></div><a href="/2018/04/16/算法-经典的Top-K问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/20/go-gc/" class="post-title-link">常见GC算法及Golang GC</a></h2><div class="tags"><a href="/tags/go/" class="tag-title">#go</a><a href="/tags/golang/" class="tag-title">#golang</a><a href="/tags/gc/" class="tag-title">#gc</a></div><div class="post-info">Mar 20, 2018</div><div class="post-content"><p>Go语言能够支持实时的，高并发的消息系统，在高达百万级别的消息系统中能够将延迟降低到100ms以下，这一切很大一部分需要归功于Go的高效的垃圾回收系统.</p></div><a href="/2018/03/20/go-gc/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/04/19/Golang内存管理/" class="post-title-link">Golang内存管理</a></h2><div class="tags"><a href="/tags/Go/" class="tag-title">#Go</a><a href="/tags/Go源码分析/" class="tag-title">#Go源码分析</a></div><div class="post-info">Apr 19, 2017</div><div class="post-content"><p>Golang 的内存管理基于 tcmalloc，可以说起点挺高的。但是 Golang 在实现的时候还做了很多优化，我们下面通过源码来看一下 Golang 的内存管理实现。下面的源码分析基于 go1.8rc3。</p></div><a href="/2017/04/19/Golang内存管理/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/fitzix">fitzix</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/fitzix/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-137176691-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())
gtag('config', 'UA-137176691-1');</script></body></html>